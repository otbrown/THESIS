In this section we consider variational searches using matrix product states. We will first discuss the theoretical underpinnings of such a technique -- what we vary, and what we search for. I will then describe how to use my own implementations of this technique -- one to perform a ground state search, and one to perform a stationary state search. There is no suggestion that my implementation represents best practise, or is in any sense \emph{the right way} to perform these calculations. It is merely how \emph{I} approached the problem. Both implementations were written in and for MATLAB \cite{MATLAB}, and can at time of writing be found in repositories hosted at Ref~\cite{otb:githome}.
 
 \subsection{Theory}
It is well known that one can use the Rayleigh-Ritz Variational Technique to find an approximation to the lowest eigenvalue and corresponding eigenfunction of a Hermitian operator. Given a set of variational parameters upon which the eigenfunctions depend, one can move always to a lower eigenvalue, by minimising over one parameter at a time \cite{ArfWeb_RRVT, Gasiorowicz_RVT}. Consequently, we can find an approximation to the ground state of a system by minimising the expression,
\begin{equation}
E = \frac{\langle \psi (\mathbf{x}^{*}) | \hat{H} | \psi (\mathbf{x}) \rangle}{\langle \psi (\mathbf{x}^{*}) | \psi (\mathbf{x}) \rangle},
\label{eq:vs1-1}
\end{equation}
with respect to some \(x\), where E is the energy of the system, \(\hat{H}\) is a Hamiltonian, \(\psi\) is an approximation to the ground state, and \( \mathbf{x} \) is a set of \emph{variational parameters}. Equally, we can find an approximation to the stationary state of an open quantum system by minimising the expression,
\begin{equation}
\frac{\mathrm{d}\rho}{\mathrm{d}t} = \langle \rho(\mathbf{x}^{*}) | \hat{\mathcal{L}^{\dagger}} \hat{\mathcal{L}} | \rho(\mathbf{x}) \rangle,
\label{eq:vs1-2}
\end{equation}
with respect to some \(x\), where \(\hat{\mathcal{L}}\) is a Liouvillian, \(\rho\) is an approximation to the stationary state, and \(\mathbf{x}\) is again some set of variational parameters. We will discuss here in terms of the generic case in which we have some observable \(O\) we wish to minimise, which has an operator \(\hat{O}\). As such we seek to use matrix product states to minimise the expression,
\begin{equation}
\langle \psi(\mathbf{x}^{*}) | \hat{O} | \psi(\mathbf{x}) \rangle,
\label{eq:vs1-10}
\end{equation}
with respect to some \(x\). A visual representaion of the variational search procedure is provided in \cref{fig:vs1-1}.

\begin{figure}[ht!]
\centering
\includegraphics[width=0.8\linewidth]{\figpath/var_space}
\caption{A visual representation of a variational search using matrix product states. The purple background represents the total state space of the system, and the green oval is the part of that state space that can be represented by a matrix product state of some finite dimension. The orange star represents our desired solution state, and it is inaccessible to the matrix product state space. The black circle is the initial matrix product state, the black star is the nearest matrix product state approximation to the solution state, and the black squares are states through which the matrix product state transitions on its way to the solution state. The black dashed line represents a variational step -- an optimisation over one or more of the variational parameters. The transitional states may or may not have some physical meaning in the context of the variational search depending on the specifics of the system being investigated. In general, however, if one wishes to know \emph{how} a system reaches the solution state a time evolution method should be used, not a variational search.}
\label{fig:vs1-1}
\end{figure}

When using matrix product states the set of variational parameters we employ are the individual site tensors, \(A^{[n]}\). We shall discuss the search procedure as prescribed by Ulrich Schollw\"{o}ck's excellent review article \cite{Schollwoeck11}. I begin my explanation by assuming that we have already some initial matrix product state, \(\Psi_{\mathrm{init}}\) which is normalised, and has dimensions \(N \times \chi_{\mathrm{max}} \times \chi_{\mathrm{max}} \times d\), where \(N\) is the number of sites in the system, \(\chi_{\mathrm{max}}\) is the maximal allowed matrix dimension, and \(d\) is the local state space dimension. Additionally I assume we may represent the operator \(\hat{O}\) as a matrix product operator with site tensors \(O^{[n]}\). First, we construct left and right `blocks' for each site in the system. The left block for some site \(n\) is a rank-3 tensor which contains the expectation of \(\hat{O}\) from the first site up to the site \(n-1\). The right block for some site \(n\) is a rank-3 tensor which contains the expectation of \(\hat{O}\) from last site through to the site \(n+1\). This is shown diagramatically in \cref{fig:vs1-2}.

\begin{figure}[ht!]
\centering
\includegraphics[width=0.8\linewidth]{\figpath/LR_blocks}
\caption{A tensor network diagram for a system which has been partially contracted in order to form left and right blocks, \(L^{[n]}\) and \(R^{[n]}\). The upper red dot here is a tensor for the site \(n\), \(A^{[n]}\), and the lower red dot is its conjugate, \(A^{\dagger [n]}\). The blue square is the mpo tensor \(O^{[n]}\) of some observable with an operator \(\hat{O}\). The black lines represent tensor indices which can be contracted over. If this contraction is completed it will be equivalent to a contraction over the full system, and the result will be the expectation value \(\langle \Psi | \hat{O} | \Psi \rangle \).}
\label{fig:vs1-2}
\end{figure}

The first site left block tensor \(L^{[1]}\) is just the scalar \(1\), as there are obviously no sites before the first. The second left block tensor \(L^{[2]}\) is then found by performing the contraction procedure,
\begin{align}
L^{[2]}_{r^{\prime}, c, q} &= \sum_{\sigma^{\prime}, c^{\prime}} A^{\dagger [1] \sigma^{\prime}}_{r^{\prime}, c^{\prime}} \left( \sum_{\sigma, p} O^{[1]  \sigma, \sigma^{\prime}}_{p, q} \left( \sum_{r} L^{[1]}_{c^{\prime}, r, p} A^{[1] \sigma}_{r, c} \right) \right), \notag \\
&= \sum_{\sigma^{\prime}, c^{\prime}} A^{\dagger [1] \sigma^{\prime}}_{r^{\prime}, c^{\prime}} \left( \sum_{\sigma, p} O^{[1]  \sigma, \sigma^{\prime}}_{p, q} \left( \sum_{r} A^{[1] \sigma}_{r, c} \right) \right),
\label{eq:vs1-3}
\end{align}
where \(A^{[n]}\) is the matrix product state tensor for the site \(n\), \(\sigma\) indexes the local physical state, \(r\) and \(c\) (`row' and `column') index the local virtual dimensions, primed indices relate to the conjugate matrix product state tensor \(A^{\dagger [n]}\), and \(p\) and \(q\) index the virtual dimensions of the matrix product operator. The procedure continues from there, much as you might expect, by moving on to the third site and so on until the last site is reached. The general formula for \(L^{[n]}\) is,
\begin{equation} 
L^{[n]}_{r^{\prime}, c, q} = \sum_{\sigma^{\prime}, c^{\prime}} A^{\dagger [n-1] \sigma^{\prime}}_{r^{\prime}, c^{\prime}} \left( \sum_{\sigma, p} O^{[n-1]  \sigma, \sigma^{\prime}}_{p, q} \left( \sum_{r} L^{[n-1]}_{c^{\prime}, r, p} A^{[n-1] \sigma}_{r, c} \right) \right).
\label{eq:vs1-4}
\end{equation}

The procedure for forming the right block is naturally very similar, starting from the last site with \(R^{[N]} = 1\) and,
\begin{equation}
R^{[n]}_{c^{\prime}, r, p} = \sum_{\sigma^{\prime}, r^{\prime}} A^{\dagger [n+1] \sigma^{\prime}}_{r^{\prime}, c^{\prime}} \left( \sum_{\sigma, q} O^{[n+1] \sigma, \sigma^{\prime}}_{p, q} \left( \sum_{c} R^{[n+1]}_{r^{\prime}, c, q} A^{[n+1] \sigma}_{r, c} \right) \right).  
\label{eq:vs1-5}
\end{equation}
Once we have formed these left and right blocks at each site, we move on to the variational procedure proper. 

We will sweep backwards and forwards through the system, updating each site tensor to minimise the energy of the overall state. Referring back to \cref{eq:vs1-1} we can see that it can be minimised by being rephrased as an eigenvalue problem,
\begin{align}
\frac{\langle \psi(\mathbf{x}^{*}) | \hat{H} | \psi(\mathbf{x}) \rangle}{\langle \psi(\mathbf{x}^{*}) | \psi(\mathbf{x}) \rangle } &= E, \notag \\
\Rightarrow \langle \psi(\mathbf{x}^{*}) | \hat{H} | \psi(\mathbf{x}) \rangle &= E \langle \psi(\mathbf{x}^{*}) | \psi(\mathbf{x}) \rangle, \notag \\
\Rightarrow \frac{\mathrm{d}}{\mathrm{d}\langle \psi(\mathbf{x}^{*}) |} \left( \langle \psi(\mathbf{x}^{*}) | \hat{H} | \psi(\mathbf{x}) \rangle \right) &= \frac{\mathrm{d}}{\mathrm{d}\langle \psi(\mathbf{x}^{*}) |} \left(  E \langle \psi(\mathbf{x}^{*}) | \psi(\mathbf{x}) \rangle \right), \notag \\
\Rightarrow \hat{H} |\psi(\mathbf{x}) \rangle &= E | \psi(\mathbf{x}) \rangle,
\label{eq:vs1-6}
\end{align}
which of course is an expression of the time-independent Schr\"{o}dinger equation. If we could solve that for the many-body state \(| \psi (\mathbf{x}) \rangle\) then we would not need matrix product states at all. Unfortunately, we cannot, but what matrix product states allow us to do is to form an effective Hamiltonian for some particular \(| \psi(x) \rangle\), and instead solve the more limited eigenvalue problem,
\begin{equation}
\hat{H}_{\mathrm{eff}} |\psi(x) \rangle = E_{[x]} |\psi(x) \rangle,
\label{eq:vs1-7}
\end{equation}
from which we simply select \(|\psi(x) \rangle\) which corresponds to the lowest real value of \(E_{[x]}\). In our case \(|\psi(x) \rangle\) is \(A^{[n]}\), and \(\hat{H}_{\mathrm{eff}}\) is formed by the contraction of the \emph{environment} of \(A^{[n]}\) \cite{Orus14}. That is we calculate,
\begin{equation}
\hat{H}_{\mathrm{eff}}^{[n]} = \langle \psi(\tilde{\mathbf{x}}) | \hat{H} | \psi(\tilde{\mathbf{x}}) \rangle,
\label{eq:vs1-8}
\end{equation}
where \(|\psi(\tilde{\mathbf{x}}) \rangle \) is our matrix product state \emph{excluding the tensor for the site \(n\)}. Such a contraction is shown diagramatically in \cref{fig:vs1-3}. Mathematically, the contraction is performed as,
\begin{equation}
\hat{H}^{[n]\, \mathrm{eff}}_{r,c,r^{\prime},c^{\prime},\sigma,\sigma^{\prime}} = \sum_{p,q} L^{[n]}_{r,r^{\prime},p} O^{[n] \sigma, \sigma^{\prime}}_{p,q} R^{[n]}_{c,c^{\prime},q},
\label{eq:vs1-9}
\end{equation}
which seems simple enough, and indeed would be except that we have an eigenvalue problem to solve. As such we require \(\hat{H}_{\mathrm{eff}}^{[n]}\) to be a matrix, not a rank-6 tensor. This can be accomplished by joining the indices corresponding to the matrix product state, and joining those of its conjugate to form a matrix \(\hat{H}^{[n]\, \mathrm{eff}}_{(\sigma ,r,c), (\sigma^{\prime},r^{\prime},c^{\prime})}\). Once this is achieved it is a simple matter of finding the eigenvector of \(\hat{H}^{[n]\, \mathrm{eff}}_{(\sigma ,r,c), (\sigma^{\prime},r^{\prime},c^{\prime})}\) with the lowest real eigenvalue. This eigenvector is the vectorised site tensor \(A^{[n]}_{\sigma, r, c}\), which we reshape to be \(A^{[n] \sigma}_{r,c}\) and use to update our matrix product state.

We do this on the first site in our system, and then re-normalise using an SVD or QR decomposition in order to make the site left-canonical. We then update the left block tensor for the second site in the system, \(L^{[2]}\) using \cref{eq:vs1-4}. We are then ready to find an effective Hamiltonian for the second site and update it. This procedure repeats sweeping `right' through our system until we reach and update the \(N\)th site -- at this point we have updated every site in the system, but it is unlikely that our observable has converged after only one such sweep. The procedure for sweeping `left' through the system back to the first site is very similar, except when re-normalising we make our newly updated site right-canonical and then update the right block, \(R^{[n]}\). In this way we are always using the most up-to-date version of the system when we calculate the effective operator for a given site. The whole procedure repeats, sweeping left and right through the system until our chosen observable converges.

\begin{figure}[ht!]
\centering
\includegraphics[width=0.8\linewidth]{\figpath/effH_diagram}
\caption{A diagrammatic representation of the contraction that must be performed in order to find the effective operator on some site \(n\). As usual the red circles represent matrix product state tensors, the blue squares represent some matrix product operator, and black lines are indices. The lines which reach into the gap left by the missing site \(n\) are indices which are left free, and will become the indices of the effective operator. As such, it can be seen that the effective operator will be a rank-6 tensor.}
\label{fig:vs1-3}
\end{figure}

\FloatBarrier
 \subsection{Ground State Implementation}
 We will now discuss my implementation of the variational ground state search. The implementation is written for MATLAB \cite{MATLAB}, and at the time of writing is held in a git repository hosted at Ref~\cite{otb:gitVGSS}. In this section we will use the conventions that \(N\) is the number of sites in our system, and \(d\) is the dimension of the local state space, so the total state space of our system would be \(d^{N}\). \Cref{fig:vs2-1} shows the structure of the code diagramatically.
 
 \begin{figure}[ht!]
 \centering
 \includegraphics[width=0.8\linewidth]{\figpath/mpsvgss}
 \caption{A diagram showing the structure of the variational ground state search code. Each rectangle is a function which forms part of the code, while the arrows represent return values. The return value follows the direction of the arrow i.e. \lstinline$LCan$ is called from, and returns data to, \lstinline$Can$. It can be seen that only \lstinline$Ground$, \lstinline$Can$, and \lstinline$GrowBlock$ have dependencies. The matrix product state constructor functions \lstinline$CompMPS$, and \lstinline$ProdMPS$ are not shown as they are convenience functions which help to form part of the input to \lstinline$Ground$, but are not necessary to run the calculation. They both have only one dependency, on \lstinline$MPSNorm$. Note that the built-in functions of MATLAB \cite{MATLAB} are not considered, but almost all the functions written for the variational ground state search rely on them to some extent. They are assumed to operate properly.}
 \label{fig:vs2-1}
 \end{figure}
 
 \subsubsection{Ground}
 \paragraph{Docstring}
 This is the top-level function for the variational ground state search. Dependencies are \lstinline$Can$, \lstinline$ConvTest$, \lstinline$EffH$, \lstinline$Expect$, and \lstinline$SiteUpdate$. It is in principle the only function an end-user should have to deal with. Although mentioned here, explanation of the `standard format' of matrix product state used in this implementation is deferred until the main constructor function, \lstinline$CompMPS$, is described. The standard format of the matrix product operator used throughout this implementation is described here. Much of this function is devoted to book-keeping and reporting, though it does not produce a save file by itself except one after passing convergence threshold of \(1 \times 10^{-5}\). It does however, regularly output (hopefully) useful information to stdout. The rest of the function deals with the high level implementation of the variational search keeping track of what site is being updated, which direction the current sweep through the system is going, what the current energy of the system is, and how many sweeps have been completed. 
 \begin{lstlisting} 
 function [groundMPS, energyTracker] = Ground(init_mps, mpo, THRESHOLD, RUNMAX) \end{lstlisting}
 \begin{longtabu}{X[1,l]X[4,l]}
 \hline
 Return & \\ \hline
 \lstinline$groundMPS$ & \emph{\(N \times 1\) cell array}. Contains a matrix product state representing the approximate ground state of the system -- the solution state. Matrix product state is in the standard format used in this implementation. \\
 \lstinline$energyTracker$ & \emph{Dynamic 1-dimensional complex double array}. Begins with a single element, the energy of the initial state evaluated as \(\langle \Psi_{\mathrm{init}}^{\mathrm{MPS}} | \hat{H} | \Psi_{\mathrm{init}}^{\mathrm{MPS}} \rangle \). The energy of the system is evaluated after each full sweep, and the result is stored as \lstinline$energyTracker(end + 1)$ enlarging the array up to a maximum size of \lstinline$RUNMAX$\(+ 1\), in the case where the energy does not converge. This array is used to monitor for convergence.\\ \hline
 Input & \\ \hline
 \lstinline$init_mps$ & \emph{\(N \times 1\) cell array}. Contains some initial state in the standard matrix product format used in this implementation. \\
 \lstinline$mpo$ & \emph{\(3 \times 1\) cell array}. Contains a matrix product operator representation of a Hamiltonian. \lstinline$mpo\{1\}$ contains the first site matrix product operator, \lstinline$mpo\{3\}$ contains the last site matrix product operator, and \lstinline$mpo\{2\}$ contains the bulk site matrix product operator. Each is a two dimensional complex double array, formed from \(d \times d\) blocks, as advised in section 6.1 of Ref~\cite{Schollwoeck11}. The specific size will be dependent on the Hamiltonian being represented, but if \(P\) is the number of blocks required then \lstinline$mpo\{1\}$ will be \(d \times Pd\), \lstinline$mpo\{2\}$ will be \(Pd \times Pd\), and \lstinline$mpo\{3\}$ will be \(Pd \times d\). \\
 \lstinline$THRESHOLD$ & \emph{Double}. The threshold below which the energy of the system will be considered to have converged. Should be real, greater than numerical error (whatever that may be on the relevant hardware), and less than \(1 \times 10^{-7}\) since the code won't check against this value until the energy has converged to at least that level.\\
 \lstinline$RUNMAX$ & \emph{Double}. The maximum number of site updates that will be performed before the code finishes regardless of convergence. Take care that there are \(N\) site updates per \emph{sweep}. Should be an integer value (much) greater than zero. Essentially this value is used to stop the code iterating forever when a calculation does not converge to the desired level.\\
 \hline
 \end{longtabu}
 \paragraph{Testing}
 \lstinline$GroundTest$ \& \lstinline$MPO_on-site+hop.mat$. Tests function against different local state space sizes, system sizes, and amounts of compression. Standard size, shape, type testing of return values. Checks that \lstinline$groundMPS$ is normalised. Loads simple Hamiltonian matrix product operator from \lstinline$MPO_on-site+hop.mat$ and checks that function correctly finds the \(|0_{1}0_{2}\ldots 0_{N} \rangle\) ground state.
 \paragraph{Improvements}
 \begin{itemize}
 \item MPO format could do with overhauling. In most cases the first site MPO tensor is the bottom row of the bulk MPO tensor, and the last site MPO tensor is the first column of the bulk MPO tensor, so cell array is unnecessary. Additionally, forcing the two-dimensional shape by joining virtual and physical indices is unnecessary and wastes time -- would be better to simply create a four-dimensional array. Modifying this would however require a modification to many of the lower level functions.
 \item Function only creates a save file at the convergence to \(1 \times 10^{-5}\) checkpoint. It should probably do so at the \(1 \times 10^{-7}\) checkpoint, and full convergence as well. The checkpoint thresholds should be inputs, and ideally optional.
 \end{itemize}
 
 \subsubsection{CompMPS} 
 \paragraph{Docstring}
 This is a constructor function for a random matrix product state. Its only dependency is \lstinline$MPSNorm$. It accepts some basic parameters of the physical system, and returns a normalised matrix product state of the correct size and shape in the standard format. The standard format is an \(N \times 1\) cell array, where each cell contains a three-dimensional complex double array. The third index is the physical index for that particular site, and so should run from \(1\) to \(d\). The first two indices are the first and second virtual indices for a particular site. The virtual indices should grow as we move through the system, so that the first site should be a \(1 \times d \times d\) array, and the second a \(d \times d^{2} \times d\) array, and so on until the limit set by \lstinline$COMPRESS$ is reached. At a certain point the virtual indices should begin shrinking again, such that the last site is a \(d \times 1 \times d\) array. This function and the other constructor, \lstinline$ProdMPS$ ensure this is the case.  
 \begin{lstlisting}egins with a single element, the energy of the initial state evaluated as \(\langle \Psi_{\mathrm{init}}^{\mathrm{MPS}} | \hat{H} | \Psi_{\mathrm{init}}^{\mathrm{MPS}} \rangle \). The energy of the system is evaluated after each full sweep, and the result is stored as \lstinline$energyTracker(end + 1)$ enlarging the array up to a maximum size of \lstinline$RUNMAX$\(+ 1\), in the case where the energy does not converge.
 function [complexMPS] = CompMPS(HILBY, L, COMPRESS) \end{lstlisting}
 \begin{longtabu}{X[1,l]X[4,l]}
 \hline
 Return & \\ \hline
 \lstinline$complexMPS$ & \emph{\lstinline$L$ \(\times 1\) cell array}. Contains a normalised matrix product state in the standard format with arrays that are at most \lstinline$COMPRESS$ \(\times\) \lstinline$COMPRESS$ \(\times\) \lstinline$HILBY$ in size. Each array is filled with random complex numbers generated using the MATLAB function \lstinline$rand$ in the form \lstinline$complexMPS\{site\} = rand(rowSize, colSize, HILBY) + 1i * rand(rowSize, colSize, HILBY)$. \\ \hline
 Input & \\ \hline
 \lstinline$HILBY$ & \emph{Double}. The size of the local state space, which we have previously referred to as \(d\). Should be a positive integer greater than 1.  \\
 \lstinline$L$ & \emph{Double}. The number of sites in the system, which we have previously referred to as \(N\). Should be a positive integer greater than 1. \\
 \lstinline$COMPRESS$ & \emph{Double}. The maximum allowed virtual dimension of the matrix prouct state tensors, which we have previously referred to as \(\chi_{\mathrm{max}}\). Note that if \lstinline$COMPRESS = 0$, it will be changed to the MATLAB value \lstinline$Inf$, meaning the matrix product state tensors will \emph{not} be compressed, and will reach a maximum size of \(d^{N/2}\).  \\
 \hline
 \end{longtabu}
 \paragraph{Testing}
 \lstinline$CompMPSTest$. Tests class, size, and shape of returned matrix product state. Uses a range of input values.
 \paragraph{Improvements}
 \begin{itemize}
 \item Testing should include checking that the returned matrix product state is properly normalised.
 \end{itemize}
 
 \subsubsection{ProdMPS}
 \paragraph{Docstring}
 This is a constructor function for a matrix product representation in the standard format of a simple product state. Its only dependence is \lstinline$MPSNorm$.
 \begin{lstlisting}
 function [matrices] = ProdMPS(stateArray, HILBY, COMPRESS) \end{lstlisting}
 \begin{longtabu}{X[1,l]X[4,l]}
 \hline
 Return & \\ \hline
 \lstinline$matrices$ & \emph{\(N \times 1\) cell array}. Contains a normalised matrix product state in the standard format, which represents the supplied product state. Formed by creating zero arrays of the correct size, and then replacing the appropriate matrices with the identity. \\ \hline
 Input & \\ \hline
 \lstinline$stateArray$ & \emph{\(N \times 1\) double array}. A column vector where each element refers to a particular site in the system, and contains the desired number state for that site. For example the three site state \(|1 1 0 \rangle\) would be supplied as \lstinline$[1; 1; 0]$. \\
 \lstinline$HILBY$ & \emph{Double}. The size of the local state space, which we have previously referred to as \(d\). Should be a positive integer greater than 1.  \\
 \lstinline$COMPRESS$ & \emph{Double}. The maximum allowed virtual dimension of the matrix prouct state tensors, which we have previously referred to as \(\chi_{\mathrm{max}}\). Note that if \lstinline$COMPRESS = 0$, it will be changed to the MATLAB value \lstinline$Inf$, meaning the matrix product state tensors will \emph{not} be compressed, and will reach a maximum size of \(d^{N/2}\).  \\
 \hline
 \end{longtabu}
 \paragraph{Improvements}
 \begin{itemize}
 \item Needs unit tests.
 \item Currently the code enforces that \lstinline$stateArray$ is a column vector, but there's no good reason for this.
 \end{itemize}
 
 \subsubsection{MPSNorm}
 \paragraph{Docstring}
 This function normalises a provided matrix product state. This is achieved by performing a QR decomposition on every site from the first, exactly as if one were making the state left-canonical. The major difference is the the final site in the system is also decomposed, and the final \(R\) matrix is simply discarded rather than being multiplied into the next site (as there is none). This ensures that \(\langle \Psi | \Psi \rangle = 1\).
 \begin{lstlisting}
 function [normalMPS] = MPSNorm(mps) \end{lstlisting}
 \begin{longtabu}{X[1,l]X[4,l]}
 \hline
 Return & \\ \hline
 \lstinline$normalMPS$ & \emph{\(N \times 1\) cell array}. Contains the normalised form of the input matrix product state, \lstinline$mps$.  \\ \hline
 Input & \\ \hline
 \lstinline$mps$ & \emph{\(N \times 1\) cell array}. Some presumably un-normalised matrix product state, in the standard format. \\
 \hline
 \end{longtabu}
 \paragraph{Testing}
 \lstinline$MPSNormTest$. Builds matrix product states using a range of system sizes and levels of compression, and then normalises them. Rebuilds the state vector and and calculates \(\langle \Psi | \Psi \rangle\). 
 \paragraph{Improvements}
 \begin{itemize}
 \item \lstinline$MPSNormTest$ calls \lstinline$CompMPS$, a function which itself depends on \lstinline$MPSNorm$. This should be avoided if possible. 
 \item \lstinline$MPSNormTest$ rebuilds the entire state vector which is never efficient, and may be avoidable. Worse, it depends on the debug function \lstinline$Rebuild$ to do so. This should be changed.
 \end{itemize}
 
 \subsubsection{Can}
 \paragraph{Docstring} This function operates as an interface for the lower level matrix product state canonisation functions, \lstinline$LCan$, and \lstinline$RCan$ -- it is dependent on them. The most important task it performs is to check the supplied canonisation route ends at an appropriate place. If the system is being made left-canonical the last site in the route cannot be \(N\) as there is no `next site'. If the system is being made right-canonical, the last site in the route cannot be \(1\) for the same reason.
 \begin{lstlisting}
 function [cmps] = Can(mps, route, DIRECTION) \end{lstlisting}
 \begin{longtabu}{X[1,l]X[4,l]}
 \hline
 Return & \\ \hline
 \lstinline$cmps$ & \emph{\(N \times 1\) cell array}. Contains the canonical form of the input matrix product state, \lstinline$mps$.  \\ \hline
 Input & \\ \hline
 \lstinline$mps$ & \emph{\(N \times 1\) cell array}. Some matrix product state, in the standard format. \\
 \lstinline$route$ & \emph{1-dimensional double array}. Contains the site, or sites which are to be made canonical. May be as small as 1 element, or as large as \(N - 1\). All values should be integers larger than 0, and no larger than \(N\), and they should form a continuous route through the system -- \lstinline$[start : 1 : stop]$. If \lstinline$DIRECTION$ is \lstinline$'L'$ and \lstinline$route(end)$ is  \(N\), or if \lstinline$DIRECTION$ is \lstinline$'R'$ and \lstinline$route(end)$ is \(1\), then the route will be rejected and a warning will be printed to stdout.\\
 \lstinline$DIRECTION$ & \emph{Character}. Should be either \lstinline$'L'$, or \lstinline$'R'$. Specifies whether the sites should be made left- or right-canonical. \\
 \hline
 \end{longtabu}
 \paragraph{Improvements}
 \begin{itemize}
 \item Needs unit testing. Although \lstinline$CanTest$ exists, it really only tests \lstinline$LCan$ and \lstinline$RCan$, and nothing specific to \lstinline$Can$.
 \item Defensive if statements test whether \lstinline$route(end)$ is \(N\) or \(1\), but not any other incorrect values. A more comprehensive defence should be used.
 \item It may be better to use the MATLAB exception framework, rather than warnings printed to stdout.
 \end{itemize}
 
 \subsubsection{GrowBlock}
 \paragraph{Docstring} This function operates as an interface to the two lower level block formation functions, \lstinline$GrowLeft$ and \lstinline$GrowRight$. It is dependent on them. When called it adds a given site tensor into either a left or right block tensor, returning either \(L^{[n+1]}\) or \(R^{[n-1]}\). It's main purpose is to keep the function call required to grow a left or right block more simple by checking the size of the matrix product state site tensor, and the matrix product operator tensor in order to generate some of the constants that \lstinline$GrowLeft$ and \lstinline$GrowRight$ require. It also ensures the correct matrix product state, and left or right block tensors are used.
 \begin{lstlisting}
 function [updateBlock] = GrowBlock(mps, mpo, TARGET, SIDE, blockCell) \end{lstlisting}
 \begin{longtabu}{X[1,l]X[4,l]}
 \hline
 Return & \\ \hline
 \lstinline$updateBlock$ & \emph{3-dimensional complex double array}. The left or right block tensor \(L^{[n+1]}\) or \(R^{[n-1]}\) from \cref{eq:vs1-4,eq:vs1-5}, where \(n\) is \lstinline$TARGET$. \\ \hline
 Input & \\ \hline
 \lstinline$mps$ & \emph{\(N \times 1\) cell array}. Some matrix product state, in the standard format. \\
 \lstinline$mpo$ & \emph{\(3 \times 1\) cell array}. A matrix product operator representation of a Hamiltonian, in the standard format. \\
 \lstinline$TARGET$ & \emph{Double}. The site which is to be included in the left or right block. Note that the left block tensor \(L^{[n]}\) does not include the site tensor \(A^{[n]}\), \emph{only} \(A^{[1]} \ldots A^{[n-1]}\). Similarly, \(R^{[n]}\) does not include \(A^{[n]}\), only \(A^{[n+1]} \ldots A^{[N]}\). Should be an integer value greater than 0 and no greater than \(N\). \\
 \lstinline$SIDE$ & \emph{Character}. Should be either \lstinline$'L'$, or \lstinline$'R'$. Specifies whether the left or right block is being updated. \\
 \lstinline$blockCell$ & \emph{\(N \times 1\) cell array}. Contains all of the \(L^{[n]}\) or \(R^{[n]}\) arrays in the format \lstinline$blockCell\{n\}$. \\
 \hline
 \end{longtabu}
 \paragraph{Improvements}
 \begin{itemize}
 \item Needs unit testing.
 \item Should defend against bad values of \lstinline$TARGET$ and if possible \lstinline$blockCell$.
 \end{itemize}
 
 \subsubsection{ConvTest}
 \paragraph{Docstring} This function tests to see if the energy of the system has converged. Exactly what `converged' means is configurable by the input parameters. The latest observed energy is subtracted from the last \lstinline$sampleSize$ observed energies. The largest absolute value resulting from this is compared against \lstinline$threshold$. If it is smaller, then a true flag is returned.
 \begin{lstlisting}
 function [convFlag] = ConvTest(energyTracker, sampleSize, threshold) \end{lstlisting}
 \begin{longtabu}{X[1,l]X[4,l]}
 \hline
 Return & \\ \hline
 \lstinline$convFlag$ & \emph{Double}. MATLAB doesn't use Boolean datatypes. Instead a non-zero double will evaluate as true, and \(0\) will evaluate as false. As such, \lstinline$convFlag$ will be returned as \(1\) if the convergence test is passed, and will be returned as \(0\) otherwise. \\ \hline
 Input & \\ \hline
 \lstinline$energyTracker$ & \emph{1-dimensional complex double array}. Contains the observed energies of the system, calculated by evaluating \(\langle \Psi | \hat{H} | \Psi \rangle\) by contracting the system as shown in \cref{fig:vs1-2}. This array changes size throughout the calculation, but is fixed at time of input to this function. It may be as small as \(1 \times 1\), or as large as \lstinline$RUNMAX$\( \times 1\). If it is smaller than \lstinline$sampleSize$\(\times 1\), then \lstinline$ConvTest$ will just return \lstinline$convFlag = 1$. \\
 \lstinline$sampleSize$ & \emph{Double}. The number of energies which will be compared to test for convergence. It should be an integer, and should obviously be less than \lstinline$RUNMAX$, however be cautioned that setting it too low will result in the energy `converging' while undergoing oscillation. It is worth inspecting \lstinline$energyTracker$ to make sure this is not the case. \\
 \lstinline$threshold$ & \emph{Double}. The threshold against which the energy's convergence will be tested. For the convergence test to return true, the absolute value of the energy of the system will not have changed by more than \lstinline$threshold$ in the last \lstinline$sampleSize$ iterations of the variational procedure. \\
 \hline
 \end{longtabu}
 \paragraph{Testing}
 \lstinline$ConvTestTest$. Throws a variety of fabricated \lstinline$energyTracker$ arrays and parameters at \lstinline$ConvTest$, and asserts that they should return 1 or 0. Looks for false positives on both undersampled, and non-converged energies.
 \paragraph{Improvements}
 \begin{itemize}
 \item There may be a more sophisticated way to test for convergence. 
\end{itemize}  

 \subsubsection{EffH}
 \paragraph{Docstring} This function calculates the effective Hamiltonian for a particular site in the system, using \cref{eq:vs1-9} which is visualised in \cref{fig:vs1-3}. In fact it returns the rank-6 tensor already reshaped into a matrix, and ready to be eigensolved.
 \begin{lstlisting}
 function [effectiveHamiltonian] = EffH(HILBY, rowMax, colMax, leftBlock, mpoTensor, rightBlock) \end{lstlisting}
 \begin{longtabu}{X[1,l]X[2,l]}
 \hline
 Return & \\ \hline
 \lstinline$effectiveHamiltonian$ & \emph{2-dimensional complex double array}. The rank-6 effective Hamiltonian tensor for site \(n\), \(\hat{H}_{\mathrm{eff}}^{[n]}\) formed by the contraction shown in \cref{eq:vs1-9}, and visualised in \cref{fig:vs1-3}. The tensor is reshaped in to a matrix, with dimensions equal to the square of the number of elements in the matrix product state tensor for site \(n\) -- (\lstinline$HILBY$\( \times \)\lstinline$rowMax$\( \times \)\lstinline$colMax$) \(\times\) (\lstinline$HILBY$\( \times \)\lstinline$rowMax$\( \times \)\lstinline$colMax$). The eigenvector of this matrix with the smallest real eigenvalue can be reshaped to replace \(A^{[n]}\). \\ \hline
 Input & \\ \hline
 \lstinline$HILBY$ & \emph{Double}. The size of the local state space, which we have previously referred to as \(d\). Should be a positive integer greater than 1. \\
 \lstinline$rowMax$ & \emph{Double}. The size of the first virtual dimension of the matrix product state tensor for site \(n\), \(A^{[n]}\). Should be a positive integer. Will range between 1 and \(\chi_{\mathrm{max}}\).\\
 \lstinline$colMax$ & \emph{Double}. The size of the second virtual dimension of the matrix product state tensor for site \(n\), \(A^{[n]}\). Should be a positive integer. Will range between 1 and \(\chi_{\mathrm{max}}\).\\
 \lstinline$leftBlock$ & \emph{3-dimensional complex double array}. The rank-3 left block tensor for site \(n\), \(L^{[n]}\). Contains the contraction of the the expectation over the Hamiltonian from the first site, up to the site \(n-1\), as shown in \cref{eq:vs1-4}.\\
 \lstinline$mpoTensor$ & \emph{2-dimensional complex double array}. The relevant matrix product operator tensor for the site \(n\), \(\hat{O}^{[n]}\). A rank-4 tensor, but the format used throughout this code is a matrix, formed from \(d \times d\) blocks, which are indexed by the tensor's virtual indices.\\
 \lstinline$rightBlock$ & \emph{3-dimensional complex double array}. The rank-3 right block tensor for site \(n\), \(R^{[n]}\). Contains the contraction of the the expectation over the Hamiltonian up to the site \(n+1\), from the last site, as shown in \cref{eq:vs1-5}.\\
 \hline
 \end{longtabu}
 \paragraph{Testing}
 \lstinline$EffHTest$ \& \lstinline$MPO_on-site+hop.mat$. Forms a random uncompressed nine qubit matrix product state, and uses the Hamiltonian matrix product operator from \lstinline$MPO_on-site+hop.mat$. Forms the effective Hamiltonian at each site, and checks that it is Hermitian. 
 \paragraph{Improvements} 
 \begin{itemize}
 \item The contraction and the reshape should be two separate functions. This function \emph{has} been optimised, but as a result is almost impossible to read and understand, and combining the contraction with the reshape to a matrix doesn't help that. 
 \item Some way of testing that the effective Hamiltonian was right would certainly help. 
 \end{itemize}
 
 \subsubsection{Expect}
 \paragraph{Docstring} This function calculates the expectation value of the Hamiltonian, \(\langle \Psi_{\mathrm{MPS}} | \hat{H} | \Psi_{\mathrm{MPS}} \rangle\). It performs a contraction using the left and right block tensors, and the matrix product state site tensors for a single site, in the manner visualised in \cref{fig:vs1-2}. In general this function performs best on the first and last site, as the dimensions are reduced.
 \begin{lstlisting}
 function [expectationValue] = Expect(mps, mpo, leftBlock, rightBlock, TARGET) \end{lstlisting}
 \begin{longtabu}{X[1,l]X[3,l]}
 \hline
 Return & \\ \hline
 \lstinline$expectationValue$ & \emph{Complex double}. This is the expectation value \(\langle \Psi | \hat{H} | \Psi \rangle\). Although it is evaluated `at a site', it is the expectation value for the whole system. The \lstinline$leftBlock$ and \lstinline$rightBlock$ contain contractions through to either side of the target site. Using the already contracted left and right blocks is considerably faster than always contracting through the entire system. This function is called after every site update in order to monitor the energy of the system for convergence.  \\ \hline
 Input & \\ \hline
 \lstinline$mps$ & \emph{\(N \times 1\) cell array}. Some matrix product state, in the standard format. \\
 \lstinline$mpo$ & \emph{\(3 \times 1\) cell array}. A matrix product operator of a Hamiltonian, in the standard format.\\
 \lstinline$leftBlock$ & \emph{3-dimensional complex double array}. The rank-3 left block tensor for site \(n\), \(L^{[n]}\). Contains the contraction of the the expectation over the Hamiltonian from the first site, up to the site \(n-1\), as shown in \cref{eq:vs1-4}.\\
 \lstinline$rightBlock$ & \emph{3-dimensional complex double array}. The rank-3 right block tensor for site \(n\), \(R^{[n]}\). Contains the contraction of the the expectation over the Hamiltonian up to the site \(n+1\), from the last site, as shown in \cref{eq:vs1-5}. \\
 \lstinline$TARGET$ & \emph{Double}. The site \(n\) at which the contraction to calculate \(\langle \Psi | \hat{H} | \Psi \rangle\) is to be completed. Can be any integer from \(1\) to \(N\), but should match with \lstinline$leftBlock$ and \lstinline$rightBlock$. In the context of the variational search, this is evaluated at the site on which an update has just been performed in order to calculate the new energy of the system. \\
 \hline
 \end{longtabu}
 \paragraph{Testing} \lstinline$ExpectTest$. Builds random matrix product states using a range of local Hilbert space sizes, system sizes, and levels of compression. Calculates the expectation value of the identity operator -- the norm of the state -- and asserts that it is \(1\). This works as long as the state is properly normalised.
 \paragraph{Improvements}
 \begin{itemize}
 \item Some defense against using left and right blocks that did not relate to the correct site. Currently the calculation would fail if the sites happened to have different size matrices, otherwise it just outputs the wrong answer.
 \item \lstinline$ExpectTest$ does not normalise the matrix product states, but assumes that they are normalised. Changing this may of course introduce an unwanted dependence on \lstinline$MPSNorm$. 
 \item \lstinline$ExpectTest$ always evaluates the \(\langle \Psi | \mathbb{I} | \Psi \rangle\) at the central site. It would be good to verify that the evaluation returned the same result when performed at different sites.
 \end{itemize} 
 
 \subsubsection{GrowLeft}
 \paragraph{Docstring} This is a low-level function interfaced by \lstinline$GrowBlock$. It is responsible for contracting a matrix product site tensor, \(A^{[n]}\), into a left block tensor \(L^{[n]}\) in order to find the left block tensor \(L^{[n+1]}\). It implements the contraction shown in \cref{eq:vs1-4}. 
 \begin{lstlisting}
 function [updateBlock] = GrowLeft(siteTensor, mpoTensor, leftBlock, rowMax, colMax, HILBY, opRowMax, opColMax, OPCOUNT) \end{lstlisting}
 \begin{longtabu}{X[1,l]X[4,l]}
 \hline
 Return & \\ \hline
 \lstinline$updateBlock$ & \emph{3-dimensional complex double array}. The left block tensor for the site \(n+1\), \(L^{[n+1]}\). \\ \hline
 Input & \\ \hline
 \lstinline$siteTensor$ & \emph{3-dimensional complex double array}. The matrix product state tensor for the site \(n\), in the standard format. \\
 \lstinline$mpoTensor$ & \emph{2-dimensional complex double array}. The matrix product operator tensor for the site \(n\), in the standard format. \\
 \lstinline$leftBlock$ & \emph{3-dimensional complex double array}. The rank-3 left block tensor for site \(n\), \(L^{[n]}\). Contains the contraction of the the expectation over the Hamiltonian from the first site, up to the site \(n-1\), as shown in \cref{eq:vs1-4}. \\
 \lstinline$rowMax$ & \emph{Double}. The size of the first virtual dimension of the matrix product state tensor for site \(n\), \(A^{[n]}\). Should be a positive integer. Will range between 1 and \(\chi_{\mathrm{max}}\).\\
 \lstinline$colMax$ & \emph{Double}. The size of the second virtual dimension of the matrix product state tensor for site \(n\), \(A^{[n]}\). Should be a positive integer. Will range between 1 and \(\chi_{\mathrm{max}}\).\\
 \lstinline$HILBY$ & \emph{Double}. The size of the local state space, which we have previously referred to as \(d\). Should be a positive integer greater than 1. \\
 \lstinline$opRowMax$ & \emph{Double}. The size of the first virtual dimension of the matrix product operator tensor for site \(n\), \(\hat{O}^{[n]}\), \emph{when indexed from zero}. Should be a positive integer. Indexed from zero in this case as it is used to generate a linear index. \\
 \lstinline$opColMax$ & \emph{Double}. The size of the second virtual dimension of the matrix product operator tensor for site \(n\), \(\hat{O}^{[n]}\), \emph{when indexed from zero}. Should be a positive integer. Indexed from zero in this case as it is used to generate a linear index. \\
 \lstinline$OPCOUNT$ & \emph{Double}. The larger of \lstinline$opRowMax$ and \lstinline$opColMax$ plus one. The maximum virtual dimension of the matrix product operator tensor for site \(n\), \(\hat{O}^{[n]}\), \emph{when indexed from one}. Should be a positive integer. \\
 \hline
 \end{longtabu}
 \paragraph{Improvements}
 \begin{itemize}
 \item Needs unit testing.
 \end{itemize}
 
 \subsubsection{GrowRight}
 \paragraph{Docstring} This is a low-level function interfaced by \lstinline$GrowBlock$. It is responsible for contracting a matrix product site tensor, \(A^{[n]}\), into a right block tensor \(R^{[n]}\) in order to find the right block tensor \(R^{[n-1]}\). It implements the contraction shown in \cref{eq:vs1-5}. 
 \begin{lstlisting}
 function [updateBlock] = GrowRight(siteTensor, mpoTensor, rightBlock, rowMax, colMax, HILBY, opRowMax, opColMax, OPCOUNT) \end{lstlisting}
 \begin{longtabu}{X[1,l]X[4,l]}
 \hline
 Return & \\ \hline
 \lstinline$updateBlock$ & \emph{3-dimensional complex double array}. The right block tensor for the site \(n-1\), \(R^{[n-1]}\). \\ \hline
 Input & \\ \hline
 \lstinline$siteTensor$ & \emph{3-dimensional complex double array}. The matrix product state tensor for the site \(n\), in the standard format. \\
 \lstinline$mpoTensor$ & \emph{2-dimensional complex double array}. The matrix product operator tensor for the site \(n\), in the standard format. \\
 \lstinline$rightBlock$ & \emph{3-dimensional complex double array}. The rank-3 right block tensor for site \(n\), \(R^{[n]}\). Contains the contraction of the the expectation over the Hamiltonian from the last site, to the site \(n+1\), as shown in \cref{eq:vs1-5}. \\
 \lstinline$rowMax$ & \emph{Double}. The size of the first virtual dimension of the matrix product state tensor for site \(n\), \(A^{[n]}\). Should be a positive integer. Will range between 1 and \(\chi_{\mathrm{max}}\).\\
 \lstinline$colMax$ & \emph{Double}. The size of the second virtual dimension of the matrix product state tensor for site \(n\), \(A^{[n]}\). Should be a positive integer. Will range between 1 and \(\chi_{\mathrm{max}}\).\\
 \lstinline$HILBY$ & \emph{Double}. The size of the local state space, which we have previously referred to as \(d\). Should be a positive integer greater than 1. \\
 \lstinline$opRowMax$ & \emph{Double}. The size of the first virtual dimension of the matrix product operator tensor for site \(n\), \(\hat{O}^{[n]}\), \emph{when indexed from zero}. Should be a positive integer. Indexed from zero in this case as it is used to generate a linear index. \\
 \lstinline$opColMax$ & \emph{Double}. The size of the second virtual dimension of the matrix product operator tensor for site \(n\), \(\hat{O}^{[n]}\), \emph{when indexed from zero}. Should be a positive integer. Indexed from zero in this case as it is used to generate a linear index. \\
 \lstinline$OPCOUNT$ & \emph{Double}. The larger of \lstinline$opRowMax$ and \lstinline$opColMax$ plus one. The maximum virtual dimension of the matrix product operator tensor for site \(n\), \(\hat{O}^{[n]}\), \emph{when indexed from one}. Should be a positive integer. \\
 \hline
 \end{longtabu}
 \paragraph{Improvements}
 \begin{itemize}
 \item Needs unit testing.
 \end{itemize}
 
 \subsubsection{LCan}
 \paragraph{Docstring} This is a low-level function interfaced by \lstinline$Can$. It is responsible for renormalising a site tensor, or continuous set of site tensors so that they are left-canonical. This is achieved using a QR decomposition, as it is faster than an SVD decomposition. The site tensor \(A^{[n]}\) is reshaped to form the matrix \(M\) which is decomposed as \(M=QR\). The \(Q\) matrix is reshaped to replace the site tensor \(A^{[n]}\), and \(R\) is multiplied in to the next site tensor along, \(A^{[n+1]}\).
 \begin{lstlisting}
 function [lmps] = LCan(mps, route) \end{lstlisting}
 \begin{longtabu}{X[1,l]X[4,l]}
 \hline
 Return & \\ \hline
 \lstinline$lmps$ & \emph{\(N \times 1\) cell array}. A matrix product state in the standard format, with sites along the specified route made left-canonical. \\ \hline
 Input & \\ \hline
 \lstinline$mps$ & \emph{\(N \times 1\) cell array}. A matrix product state, in the standard format. \\
 \lstinline$route$ & \emph{1-dimensional double array}. Contains the site, or sites which are to be made canonical. May be as small as 1 element, or as large as \(N - 1\). All values should be integers larger than 0, and less than \(N\), and they should form a continuous route through the system -- \lstinline$[start : 1 : stop]$. \\
 \hline
 \end{longtabu}
 \paragraph{Testing}
 \lstinline$CanTest.m$. Creates random matrix product states using a range of local state space sizes, system sizes, and levels of compression. Checks that using \lstinline$LCan$ does not affect the norm of the matrix product state, and does not change the state it represents.
 \paragraph{Improvements}
 \begin{itemize}
 \item \lstinline$CanTest$ relies on the debug function \lstinline$Rebuild$ to check state does not change -- this is not ideal. Instead of rebuilding the entire state vector, elements from it could be sampled.
 \end{itemize}

 \subsubsection{RCan}
 \paragraph{Docstring} This is a low-level function interfaced by \lstinline$Can$. It is responsible for renormalising a site tensor, or continuous set of site tensors so that they are right-canonical. The site tensor \(A^{[n]}\) is reshaped into the matrix \(M\) which is decomposed as \(M = USV^{\dagger}\). The unitary matrix \(V^{\dagger}\) is reshaped to form the new site tensor \(A^{[n]}\), and \(US\) is multiplied in to the next site tensor along, \(A^{[n-1]}\).
 \begin{lstlisting}
 function [rmps] = RCan(mps, route) \end{lstlisting}
 \begin{longtabu}{X[1,l]X[4,l]}
 \hline
 Return & \\ \hline
 \lstinline$rmps$ & \emph{\(N \times 1\) cell array}. A matrix product state in the standard format, with sites along the specified route made right-canonical. \\ \hline
 Input & \\ \hline
 \lstinline$mps$ & \emph{\(N \times 1\) cell array}. A matrix product state, in the standard format. \\
 \lstinline$route$ & \emph{1-dimensional double array}. Contains the site, or sites which are to be made canonical. May be as small as 1 element, or as large as \(N - 1\). All values should be integers larger than 1, and no larger than \(N\), and they should form a continuous route through the system -- \lstinline$[start : -1 : stop]$. \\
 \hline
 \end{longtabu}
 \paragraph{Testing}
  \lstinline$CanTest.m$. Creates random matrix product states using a range of local state space sizes, system sizes, and levels of compression. Checks that using \lstinline$RCan$ does not affect the norm of the matrix product state, and does not change the state it represents.
  \paragraph{Improvements}
  \begin{itemize}
  \item The QR decomposition is considerably faster than the SVD, and could be used here instead.
  \item \lstinline$CanTest$ relies on the debug function \lstinline$Rebuild$ to check state does not change -- this is not ideal. Instead of rebuilding the entire state vector, elements from it could be sampled.
  \end{itemize}
  
 \subsubsection{SiteUpdate}
 \paragraph{Docstring} A very simple function that takes an eigenvector of \(H^{[n]}_{\mathrm{eff}}\) and reshapes it to form the new rank-3 site tensor, \(A^{[n]}\). 
 \begin{lstlisting}
 function [updateMatrix] = SiteUpdate(eigVec, rowMax, colMax, HILBY) \end{lstlisting}
 \begin{longtabu}{X[1,l]X[4,l]}
 \hline
 Return & \\ \hline
 \lstinline$updateMatrix$ & \emph{3-dimensional complex double array}. The new rank-3 site tensor \(A^{[n]}\). \\ \hline
 Input & \\ \hline
 \lstinline$eigVec$ & \emph{1-dimensional complex double array}. An eigenvector of the effective Hamiltonian for the site \(n\). Must have dimension \lstinline$rowMax$\(\times\)\lstinline$colMax$\(\times\)\lstinline$HILBY$. \\
 \lstinline$rowMax$ & \emph{Double}. The size of the first virtual dimension of the matrix product state tensor for site \(n\), \(A^{[n]}\). Should be a positive integer. Will range between 1 and \(\chi_{\mathrm{max}}\).\\
 \lstinline$colMax$ & \emph{Double}. The size of the second virtual dimension of the matrix product state tensor for site \(n\), \(A^{[n]}\). Should be a positive integer. Will range between 1 and \(\chi_{\mathrm{max}}\).\\
 \lstinline$HILBY$ & \emph{Double}. The size of the local state space, which we have previously referred to as \(d\). Should be a positive integer greater than 1. \\
 \hline
 \end{longtabu}
 
\FloatBarrier 
 
 \subsection{Stationary State Implementation}
 We will now discuss the variational stationary state search. The implementation is also written for MATLAB \cite{MATLAB}, and at the time of writing is held in a git repository hosted at Ref~\cite{otb:gitVSSS}. In this section we will use the conventions that \(N\) is the number of sites in our system, and \(d\) is the dimension of the local state space, so the total state space of our system would be \(d^{N}\), and the full density matrix has \(d^{2N}\) elements. \Cref{fig:vs2-2} shows the structure of the code diagramatically. The principle difference between this and the ground state search code, is that our matrix product state now has two physical indices, \(|i \rangle \langle j |\), and our matrix product operator has four. To make the dsitinction clear, we refer to the matrix product state as a `density matrix product operator'. In order to write this code I referred to the ever useful Ref~\cite{Schollwoeck11}, and also to two more recent papers which dealt specifically with variational stationary state searches \cite{CCB15,MFS15}.
 
 \subsubsection{Top-Level Function}
 Not yet written. Will control the stationary state search.
 
 \subsubsection{DMPO}
 \paragraph{Docstring} This is a constructor function for a density matrix product operator,
 \begin{equation}
 |\bar{\rho} \rangle = \sum_{i_{1} \ldots i_{N}, j_{1} \ldots j_{N}} A^{[1]}_{i,j} A^{[2]}_{i,j} \ldots A^{[N]}_{i,j} | j_{1} \ldots j_{N} \rangle \otimes |i_{1} \ldots i_{N} \rangle,
 \label{eq:vs3-1}
 \end{equation}
 where, similar to \lstinline$CompMPS$, the site tensors are constructed using the MATLAB \lstinline$rand$ function. The standard format of density matrix product operator is again an \(N \times 1\) cell array, only now each cell contains a four dimensional complex double array representing \(A^{[n]}\). The first site has dimensions \(1 \times d^{2} \times d \times d\), and the last has dimensions \(d^{2} \times 1 \times d \times d\), with the sites in between growing up to \(\chi_{\mathrm{max}} \times \chi_{\mathrm{max}} \times d \times d\) in size. The first two dimensions are the virtual indices, and the second two are the physical indices. The first physical index corresponds to \(i\), and the second corresponds to \(j\) in \(| i \rangle \langle j|\). The first is usually given the variable name \lstinline$braState$, while the second is usually given the variable name \lstinline$ketState$. This may seem the wrong way round, but it is based on how the elements of the density matrix would be picked out as in \(\langle i | \rho | j \rangle\). This function depends on \lstinline$SVDNorm$, \lstinline$DMPOHerm$, \lstinline$DMPOCompress$, and \lstinline$TrNorm$.
 \begin{lstlisting}
 function [dmpo] = DMPO(HILBY, LENGTH, COMPRESS) \end{lstlisting}
 \begin{longtabu}{X[1,l]X[4,l]}
 \hline
 Return & \\ \hline
 \lstinline$dmpo$ & \emph{\(N \times 1\) cell array}. A density matrix product operator initialised to some random state, in the standard format described in the docstring. Each site tensor is formed by calling the MATLAB \lstinline$rand$ function in the form \lstinline$dmpo\{site\} = rand(rowSz, colSz, HILBY, HILBY) + 1i * rand(rowSz, colSz, HILBY, HILBY)$. The density matrix product operator is then vector normalised, to which is necessary for the variational procedure. An attempt is then made to make the state more physical -- the state is made Hermitian, compressed, and then trace normalised. Unfortunately, as every element of every site tensor has some complex value, the result is a highly entangled state which is sensitive to compression. As a result, the Hermiticity of the state will not survive the compression step. \\ \hline
 Input & \\ \hline
 \lstinline$HILBY$ & \emph{Double}. As in the ground state code, this is the size of the local state space, \(d\). Should be a positive integer, greater than 1.  \\
 \lstinline$LENGTH$ & \emph{Double}. The number of sites in the system, \(N\). Should be a positive integer greater than 1. \\
 \lstinline$COMPRESS$ & \emph{Double}. The maximum size, \(\chi_{\mathrm{max}}\) of the virtual dimensions of the density matrix product state site tensors, \(A^{[n]}\). As in the ground state code, if \lstinline$COMPRESS == 0$, it will be set to \lstinline$Inf$, leaving the density matrix product operator uncompressed. Should be a positive integer either equal to zero, or greater than or equal to \(d^{2}\). If \(0 <\) \lstinline$COMPRESS$ \(< d^{2}\) an error will be thrown. \\
 \hline
 \end{longtabu}
 \paragraph{Testing} \lstinline$DMPOTest$. Checks that the density matrix product operator is the right type, size, and shape, including that compression is properly applied. Additionally, the test checks that the error \lstinline$DMPO:BadCOMPRESS$ is thrown in the event of a bad value of \lstinline$COMPRESS$ being supplied, and that the state is trace normalised.
  
 \subsubsection{DMPOHerm}
 \paragraph{Docstring} This function returns the Hermitian part of a supplied density matrix product operator. It does this by performing the following operation, 
 \begin{equation}
 \tilde{\rho} = \frac{\rho + \rho^{\dagger}}{2}.
 \label{eq:vs3-2}
 \end{equation}
 It should be noted that the operation to add two matrix product operators involves doubling the size of the virtual dimensions on each site. Consequently, this function will do the same regardless of what compression limits may have been previously set. The state should therefore be compressed after the use of this function. This function depends on \lstinline$DMPOConj$, \lstinline$DMPOSum$, and \lstinline$DMPOScalarDiv$.
 \begin{lstlisting}
 function [hermDMPO] = DMPOHerm(dmpo) \end{lstlisting}
 \begin{longtabu}{X[1,l]X[4,l]}
 \hline
 Return & \\ \hline
 \lstinline$hermDMPO$ & \emph{\(N \times 1\) cell array}. The hermitian part of the supplied density matrix product operator, in the standard format. Will have double the virtual dimensions on each site, so should be compressed. \\ \hline
 Input & \\ \hline
 \lstinline$dmpo$ & \emph{\(N \times 1\) cell array}. Some density matrix product operator, in the standard format. \\
 \hline
 \end{longtabu}
 \paragraph{Testing} \lstinline$DMPOHermTest$. Checks the \lstinline$hermDMPO$ has the right type, size, and shape. Additionally checks that the trace has been preserved from the input, that the trace is real, and that \lstinline$hermDMPO$ is Hermitian. It does the test for Hermiticity by sampling elements from the density matrix, and checking the transpose element.
 
 \subsubsection{ProdDMPO}
 \paragraph{Docstring} This is a constructor function for a density matrix product operator. It creates a density matrix product operator which represents a specified simple product state. That is it forms the density matrix,
 \begin{equation}
 \rho = | i_{1} i_{2} \ldots i_{N} \rangle \langle i_{1} i_{2} \ldots i_{N} |,
 \label{eq:vs3-3}
 \end{equation}
 for some product state \(|i_{1} i_{2} \ldots i_{N} \rangle\). This function depends on \lstinline$FWBase$.
 \begin{lstlisting}
 function [prodDMPO] = ProdDMPO(HILBY, LENGTH, COMPRESS, STATE) \end{lstlisting}
 \begin{longtabu}{X[1,l]X[4,l]}
 \hline
 Return & \\ \hline
 \lstinline$prodDMPO$ & \emph{\(N \times 1\) cell array}. A density matrix product operator in the standard format which corresponds to a simple product state, specified by \lstinline$STATE$. Created by initialising all tensors \(A^{[n]}\) as zero arrays, and then replacing the appropriate \(A^{[n]}_{i,j}\) matrices with identities. \\ \hline
 Input & \\ \hline
 \lstinline$HILBY$ & \emph{Double}. The size of the local state space, \(d\). Should be a positive integer, greater than 1. \\
 \lstinline$LENGTH$ & \emph{Double}. The number of sites in the system, \(N\). Should be a positive integer, greater than 1. \\
 \lstinline$COMPRESS$ & \emph{Double}. The maximum size, \(\chi_{\mathrm{max}}\) of the virtual dimensions of the density matrix product state site tensors, \(A^{[n]}\). If \lstinline$COMPRESS == 0$, it will be set to \lstinline$Inf$, leaving the density matrix product operator uncompressed. Should be a positive integer either equal to zero, or greater than or equal to \(d^{2}\). If \(0 <\) \lstinline$COMPRESS$ \(< d^{2}\) an error will be thrown. \\
 \lstinline$STATE$ & \emph{Double}. The decimal value given by treating the desired state as a big-endian, \(N\)-bit, base \(d\) string. For example for any size system, \lstinline$STATE = 0$ gives the state \(| 0_{1} 0_{2} \ldots 0_{N} \rangle \). For a 3 site, 3-level system, \lstinline$STATE = 12$ would correspond to the state \(|1_{1} 1_{2} 0_{3} \rangle\).  \\
 \hline
 \end{longtabu}
 \paragraph{Testing} \lstinline$ProdDMPOTest$. Checks the type, size, and shape of the density matrix product operator. It checks that compression is properly applied, and that the error \lstinline$ProdDMPO:BadCOMPRESS$ is thrown if a bad value of \lstinline$COMPRESS$ is supplied. It checks that the trace is one, and that the specific density matrix element corresponding to the specified state is one.
 
 \subsubsection{SuperDMPO}
 \paragraph{Docstring} This is a constructor function for a density matrix product operator. It creates a density matrix product operator which represents a normalised density matrix with the same real value in every element, which itself corresponds to an even superposition state. For example, for a two qubit system \lstinline$SuperDMPO$ would create a density matrix product operator corresponding to the density matrix,
 \begin{equation}
 \rho = \begin{pmatrix}
 0.5 & 0.5 \\
 0.5 & 0.5 \end{pmatrix}.
 \label{eq:vs3-4}
 \end{equation} 
 This function depends on \lstinline$DMPOScalarDiv$.
 \begin{lstlisting}
 function [dmpo] = SuperDMPO(HILBY, LENGTH, COMPRESS) \end{lstlisting}
 \begin{longtabu}{X[1,l]X[4,l]}
 \hline
 Return & \\ \hline
 \lstinline$dmpo$ & \emph{\(N \times 1\) cell array}. A density matrix productor operator in the standard format which corresponds to an even superposition state. Created by making the first element in every matrix \(A^{[n]}_{i,j}\) one, with the rest all zeroes. The density matrix product operator is then divided by \(d^{N}\).  \\ \hline
 Input & \\ \hline
 \lstinline$HILBY$ & \emph{Double}. The size of the local state space, \(d\). Should be a positive integer, greater than 1. \\
 \lstinline$LENGTH$ & \emph{Double}. The number of sites in the system, \(N\). Should be a positive integer, greater than 1. \\
 \lstinline$COMPRESS$ & \emph{Double}. The maximum size, \(\chi_{\mathrm{max}}\) of the virtual dimensions of the density matrix product state site tensors, \(A^{[n]}\). If \lstinline$COMPRESS == 0$, it will be set to \lstinline$Inf$, leaving the density matrix product operator uncompressed. Should be a positive integer either equal to zero, or greater than or equal to \(d^{2}\). If \(0 <\) \lstinline$COMPRESS$ \(< d^{2}\) an error will be thrown. \\
 \hline
 \end{longtabu}  
 \paragraph{Testing} \lstinline$SuperDMPOTest$. Checks the type, size, and shape of the density matrix product operator. It checks that compression is properly applied, and that the error \lstinline$SuperDMPO:BadCOMPRESS$ is thrown if a bad value of \lstinline$COMPRESS$ is supplied. It checks that the trace is one, and that a sample of the density matrix elements are all equal to one another.
 
 \subsubsection{TrNorm}
 \paragraph{Docstring} Normalises a density matrix product operator by dividing it by its trace. This function depends on \lstinline$DMPOTrace$, and \lstinline$DMPOScalarDiv$.
 \begin{lstlisting}
 function [normDMPO] = TrNorm(dmpo) \end{lstlisting}
 \begin{longtabu}{X[1,l]X[4,l]}
 \hline
 Return & \\ \hline
 \lstinline$normDMPO$ & A trace normalised density matrix product operator, in the standard format. \\ \hline
 Input & \\ \hline
 \lstinline$dmpo$ & A density matrix product operator which is to be trace normalised, in the standard format. \\
 \hline
 \end{longtabu}
 \paragraph{Testing} \lstinline$TrNormTest$. Checks that \lstinline$normDMPO$ has the same class, size, and shape as \lstinline$dmpo$, and checks that the trace is one.
 
 \subsubsection{DMPOCompress}
 
 \subsubsection{DMPOConj}
 
 \subsubsection{DMPOExp}
 
 \subsubsection{DMPOScalarDiv}
 
 \subsubsection{DMPOSum}
 
 \subsubsection{DMPOTrace}
 
 \subsubsection{EffL}
 Not yet written. Will form the effective Liouvillian operator for a particular site.
 
 \subsubsection{FWBase}
 
 \subsubsection{GrowLeft}
 
 \subsubsection{GrowRight}
 
 \subsubsection{LCan}
 
 \subsubsection{RCan}
 
 \subsubsection{SVDNorm}