\otb{Comments written in brown.} 

In this section we consider variational searches using matrix product states. We will first discuss the theoretical underpinnings of such a technique -- what we vary, and what we search for. I will then describe how to use my own implementations of this technique -- one to perform a ground state search, and one to perform a stationary state search. There is no suggestion that my implementation represents best practise, or is in any sense \emph{the right way} to perform these calculations. It is merely how \emph{I} approached the problem. Both implementations were written in and for MATLAB \cite{MATLAB}, and can at time of writing be found in repositories hosted at Ref~\cite{otb:githome}.
 
 \subsection{Theory}
It is well known that one can use the Rayleigh-Ritz Variational Technique to find an approximation to the lowest eigenvalue and corresponding eigenfunction of a Hermitian operator. Given a set of variational parameters upon which the eigenfunctions depend, one can move always to a lower eigenvalue, by minimising over one parameter at a time \cite{ArfWeb_RRVT, Gasiorowicz_RVT}. Consequently, we can find an approximation to the ground state of a system by minimising the expression,
\begin{equation}
E = \frac{\langle \psi (\mathbf{x}^{*}) | \hat{H} | \psi (\mathbf{x}) \rangle}{\langle \psi (\mathbf{x}^{*}) | \psi (\mathbf{x}) \rangle},
\label{eq:vs1-1}
\end{equation}
with respect to some \(x\), where E is the energy of the system, \(\hat{H}\) is a Hamiltonian, \(\psi\) is an approximation to the ground state, and \( \mathbf{x} \) is a set of \emph{variational parameters}. Equally, we can find an approximation to the stationary state of an open quantum system by minimising the expression,
\begin{equation}
\frac{\mathrm{d}\rho}{\mathrm{d}t} = \langle \langle \rho(\mathbf{x}^{*}) | \hat{\mathcal{L}^{\dagger}} \hat{\mathcal{L}} | \rho(\mathbf{x}) \rangle \rangle,
\label{eq:vs1-2}
\end{equation}
with respect to some \(x\), where \(\hat{\mathcal{L}}\) is a Liouvillian, \(\rho\) is an approximation to the stationary state, and \(\mathbf{x}\) is again some set of variational parameters. The notation \(|\rho (\mathbf{x}) \rangle \rangle\) denotes the density matrix vectorised according to the isomorphism,
\begin{align}
\rho &= \sum_{ij} c_{ij} |i \rangle \langle j| \notag \\
\rightarrow | \rho \rangle \rangle &= \sum_{ij} c_{ij} |j \rangle \otimes |i \rangle,
\label{eq:vs1-11}
\end{align}
where \(|i\rangle\) is some complete set of basis states. We will discuss here the generic case in which we have some observable \(O\) we wish to minimise, which has an operator \(\hat{O}\). As such we seek to use matrix product states to minimise the expression,
\begin{equation}
\langle \psi(\mathbf{x}^{*}) | \hat{O} | \psi(\mathbf{x}) \rangle,
\label{eq:vs1-10}
\end{equation}
with respect to some \(x\). A visual representation of the variational search procedure is provided in \cref{fig:vs1-1}.

\begin{figure}[ht!]
\centering
\includegraphics[width=0.8\linewidth]{\figpath/var_space}
\caption{A visual representation of a variational search using matrix product states. The purple background represents the total state space of the system, and the green oval is the part of that state space that can be represented by a matrix product state of some finite dimension. The orange star represents our desired solution state, and it is inaccessible to the matrix product state space. The black circle is the initial matrix product state, the black star is the nearest matrix product state approximation to the solution state, and the black squares are states through which the matrix product state transitions on its way to the solution state. The black dashed line represents a variational step -- an optimisation over one or more of the variational parameters. The transitional states may or may not have some physical meaning in the context of the variational search depending on the specifics of the system being investigated. In general, however, if one wishes to know \emph{how} a system reaches the solution state a time evolution method should be used, not a variational search.}
\label{fig:vs1-1}
\end{figure}

When using matrix product states the set of variational parameters we employ are the individual site tensors, \(A^{[n]}\). We shall discuss the search procedure as prescribed by Ulrich Schollw\"{o}ck's excellent review article \cite{Schollwoeck11}. I begin my explanation by assuming that we have already some initial matrix product state, \(\Psi_{\mathrm{init}}\) which is normalised, and has dimensions \(N \times \chi_{\mathrm{max}} \times \chi_{\mathrm{max}} \times d\), where \(N\) is the number of sites in the system, \(\chi_{\mathrm{max}}\) is the maximal allowed matrix dimension, and \(d\) is the local state space dimension. Additionally I assume we may represent the operator \(\hat{O}\) as a matrix product operator with site tensors \(O^{[n]}\). First, we construct left and right `blocks' for each site in the system. The left block for some site \(n\) is a rank-3 tensor which contains the expectation of \(\hat{O}\) from the first site up to the site \(n-1\). The right block for some site \(n\) is a rank-3 tensor which contains the expectation of \(\hat{O}\) from last site through to the site \(n+1\). This is shown diagramatically in \cref{fig:vs1-2}.

\begin{figure}[ht!]
\centering
\includegraphics[width=0.8\linewidth]{\figpath/LR_blocks}
\caption{A tensor network diagram for a system which has been partially contracted in order to form left and right blocks, \(L^{[n]}\) and \(R^{[n]}\). The upper red dot here is a tensor for the site \(n\), \(A^{[n]}\), and the lower red dot is its conjugate, \(A^{\dagger [n]}\). The blue square is the mpo tensor \(O^{[n]}\) of some observable with an operator \(\hat{O}\). The black lines represent tensor indices which can be contracted over. If this contraction is completed it will be equivalent to a contraction over the full system, and the result will be the expectation value \(\langle \Psi | \hat{O} | \Psi \rangle \).}
\label{fig:vs1-2}
\end{figure}

The first site left block tensor \(L^{[1]}\) is just the scalar \(1\), as there are obviously no sites before the first. The second left block tensor \(L^{[2]}\) is then found by performing the contraction procedure,
\begin{align}
L^{[2]}_{r^{\prime}, c, q} &= \sum_{\sigma^{\prime}, c^{\prime}} A^{\dagger [1] \sigma^{\prime}}_{r^{\prime}, c^{\prime}} \left( \sum_{\sigma, p} O^{[1]  \sigma, \sigma^{\prime}}_{p, q} \left( \sum_{r} L^{[1]}_{c^{\prime}, r, p} A^{[1] \sigma}_{r, c} \right) \right), \notag \\
&= \sum_{\sigma^{\prime}, c^{\prime}} A^{\dagger [1] \sigma^{\prime}}_{r^{\prime}, c^{\prime}} \left( \sum_{\sigma, p} O^{[1]  \sigma, \sigma^{\prime}}_{p, q} \left( \sum_{r} A^{[1] \sigma}_{r, c} \right) \right),
\label{eq:vs1-3}
\end{align}
where \(A^{[n]}\) is the matrix product state tensor for the site \(n\), \(\sigma\) indexes the local physical state, \(r\) and \(c\) (`row' and `column') index the local virtual dimensions, primed indices relate to the conjugate matrix product state tensor \(A^{\dagger [n]}\), and \(p\) and \(q\) index the virtual dimensions of the matrix product operator. The procedure continues from there, much as you might expect, by moving on to the third site and so on until the last site is reached. The general formula for \(L^{[n]}\) is,
\begin{equation} 
L^{[n]}_{r^{\prime}, c, q} = \sum_{\sigma^{\prime}, c^{\prime}} A^{\dagger [n-1] \sigma^{\prime}}_{r^{\prime}, c^{\prime}} \left( \sum_{\sigma, p} O^{[n-1]  \sigma, \sigma^{\prime}}_{p, q} \left( \sum_{r} L^{[n-1]}_{c^{\prime}, r, p} A^{[n-1] \sigma}_{r, c} \right) \right),
\label{eq:vs1-4}
\end{equation}
which is shown diagramatically in \cref{fig:vs1-4}.

\begin{figure}[ht!]
\centering
\includegraphics[width=0.8\linewidth]{\figpath/L_contract}
\caption{A tensor network diagram which, when contracted, yields the `left block' for the site \(n\), \(L^{[n]}\). This is the operation described in \cref{eq:vs1-4}. The un-contracted indices \(c\), \(q\), and \(r'\), form the three dimensions of \(L^{[n]}\).}
\label{fig:vs1-4}
\end{figure}

The procedure for forming the right block is naturally very similar, starting from the last site with \(R^{[N]} = 1\) and,
\begin{equation}
R^{[n]}_{c^{\prime}, r, p} = \sum_{\sigma^{\prime}, r^{\prime}} A^{\dagger [n+1] \sigma^{\prime}}_{r^{\prime}, c^{\prime}} \left( \sum_{\sigma, q} O^{[n+1] \sigma, \sigma^{\prime}}_{p, q} \left( \sum_{c} R^{[n+1]}_{r^{\prime}, c, q} A^{[n+1] \sigma}_{r, c} \right) \right).  
\label{eq:vs1-5}
\end{equation}
Once we have formed these left and right blocks at each site, we move on to the variational procedure proper. 

We will sweep backwards and forwards through the system, updating each site tensor to minimise the energy of the overall state. Referring back to \cref{eq:vs1-1} we can see that it can be minimised by being rephrased as an eigenvalue problem,
\begin{align}
\frac{\langle \psi(\mathbf{x}^{*}) | \hat{H} | \psi(\mathbf{x}) \rangle}{\langle \psi(\mathbf{x}^{*}) | \psi(\mathbf{x}) \rangle } &= E, \notag \\
\Rightarrow \langle \psi(\mathbf{x}^{*}) | \hat{H} | \psi(\mathbf{x}) \rangle &= E \langle \psi(\mathbf{x}^{*}) | \psi(\mathbf{x}) \rangle, \notag \\
\Rightarrow \frac{\mathrm{d}}{\mathrm{d}\langle \psi(\mathbf{x}^{*}) |} \left( \langle \psi(\mathbf{x}^{*}) | \hat{H} | \psi(\mathbf{x}) \rangle \right) &= \frac{\mathrm{d}}{\mathrm{d}\langle \psi(\mathbf{x}^{*}) |} \left(  E \langle \psi(\mathbf{x}^{*}) | \psi(\mathbf{x}) \rangle \right), \notag \\
\Rightarrow \hat{H} |\psi(\mathbf{x}) \rangle &= E | \psi(\mathbf{x}) \rangle,
\label{eq:vs1-6}
\end{align}
which of course is an expression of the time-independent Schr\"{o}dinger equation. If we could solve that for the many-body state \(| \psi (\mathbf{x}) \rangle\) then we would not need matrix product states at all. Unfortunately, we cannot, but what matrix product states allow us to do is to form an effective Hamiltonian for some particular \(| \psi(x) \rangle\), and instead solve the more limited eigenvalue problem,
\begin{equation}
\hat{H}_{\mathrm{eff}} |\psi(x) \rangle = E_{[x]} |\psi(x) \rangle,
\label{eq:vs1-7}
\end{equation}
from which we simply select \(|\psi(x) \rangle\) which corresponds to the lowest real value of \(E_{[x]}\). In our case \(|\psi(x) \rangle\) is \(A^{[n]}\), and \(\hat{H}_{\mathrm{eff}}\) is formed by the contraction of the \emph{environment} of \(A^{[n]}\) \cite{Orus14}. That is we calculate,
\begin{equation}
\hat{H}_{\mathrm{eff}}^{[n]} = \langle \psi(\tilde{\mathbf{x}}) | \hat{H} | \psi(\tilde{\mathbf{x}}) \rangle,
\label{eq:vs1-8}
\end{equation}
where \(|\psi(\tilde{\mathbf{x}}) \rangle \) is our matrix product state \emph{excluding the tensor for the site \(n\)}. Such a contraction is shown diagramatically in \cref{fig:vs1-3}. Mathematically, the contraction is performed as,
\begin{equation}
\hat{H}^{[n]\, \mathrm{eff}}_{r,c,r^{\prime},c^{\prime},\sigma,\sigma^{\prime}} = \sum_{p,q} L^{[n]}_{r,r^{\prime},p} O^{[n] \sigma, \sigma^{\prime}}_{p,q} R^{[n]}_{c,c^{\prime},q},
\label{eq:vs1-9}
\end{equation}
which seems simple enough, and indeed would be except that we have an eigenvalue problem to solve. As such we require \(\hat{H}_{\mathrm{eff}}^{[n]}\) to be a matrix, not a rank-6 tensor. This can be accomplished by joining the indices corresponding to the matrix product state, and joining those of its conjugate to form a matrix \(\hat{H}^{[n]\, \mathrm{eff}}_{(\sigma ,r,c), (\sigma^{\prime},r^{\prime},c^{\prime})}\). Once this is achieved it is a simple matter of finding the eigenvector of \(\hat{H}^{[n]\, \mathrm{eff}}_{(\sigma ,r,c), (\sigma^{\prime},r^{\prime},c^{\prime})}\) corresponding to the optimal eigenvalue. Which eigenvalue depends explicitly on the problem you are trying to solve, and the eigenspectrum of the relevant operator -- some examples are given in \cref{tab:vs1-1}. This eigenvector is the vectorised site tensor \(A^{[n]}_{\sigma, r, c}\), which we reshape to be \(A^{[n] \sigma}_{r,c}\) and use to update our matrix product state.

\begin{table}[h!]
	\centering
	\begin{tabular}{l | c | c | c}
		Problem & Operator & Eigenspectrum & Optimal Eigenvalue \\ \hline
		Ground state search & Hamiltonian, \(\hat{H}\) & \(\lambda\in\mathbb{R}\) & min(\(\lambda\)) \\
		Stationary state search & Liouvillian, \(\hat{\mathcal{L}}\) & \(\lambda \in \{a + ib: a \in \mathbb{R}^{-}, b \in \mathbb{R}\}\) & max(Re(\(\lambda\))) \\
		Stationary state search & \(\hat{\mathcal{L}}^{\dagger}\hat{\mathcal{L}}\) & \(\lambda \in \mathbb{R}^{+}\) & min(\(\lambda\))  
	\end{tabular}
	\caption{Examples of appropriate optimal eigenvalues for different variational problems.}
	\label{tab:vs1-1}
\end{table}

We do this on the first site in our system, and then re-normalise using an SVD or QR decomposition in order to make the site left-canonical. We then update the left block tensor for the second site in the system, \(L^{[2]}\) using \cref{eq:vs1-4}. We are then ready to find an effective Hamiltonian for the second site and update it. This procedure repeats sweeping `right' through our system until we reach and update the \(N\)th site -- at this point we have updated every site in the system, but it is unlikely that our observable has converged after only one such sweep. The procedure for sweeping `left' through the system back to the first site is very similar, except when re-normalising we make our newly updated site right-canonical and then update the right block, \(R^{[n]}\). In this way we are always using the most up-to-date version of the system when we calculate the effective operator for a given site. The whole procedure repeats, sweeping left and right through the system until our chosen observable converges.

\begin{figure}[ht!]
\centering
\includegraphics[width=0.8\linewidth]{\figpath/effH_diagram}
\caption{A diagrammatic representation of the contraction that must be performed in order to find the effective operator on some site \(n\). As usual the red circles represent matrix product state tensors, the blue squares represent some matrix product operator, and black lines are indices. The lines which reach into the gap left by the missing site \(n\) are indices which are left free, and will become the indices of the effective operator. As such, it can be seen that the effective operator will be a rank-6 tensor.}
\label{fig:vs1-3}
\end{figure}

\FloatBarrier
 \subsection{Ground State Implementation}
 \otb{Is this section worth including, given how little use we've made of the ground state code?}  
 
 We will now discuss my implementation of the variational ground state search. The implementation is written for MATLAB \cite{MATLAB}, and at the time of writing is held in a git repository hosted at Ref~\cite{otb:gitVGSS}. In this section we will use the conventions that \(N\) is the number of sites in our system, and \(d\) is the dimension of the local state space, so the total state space of our system would be \(d^{N}\). \Cref{fig:vs2-1} shows the structure of the code diagramatically.
 
 \begin{figure}[ht!]
 \centering
 \includegraphics[width=0.8\linewidth]{\figpath/mpsvgss}
 \caption{A diagram showing the structure of the variational ground state search code. Each rectangle is a function which forms part of the code, while the arrows represent return values. The return value follows the direction of the arrow i.e. \lstinline$LCan$ is called from, and returns data to, \lstinline$Can$. It can be seen that only \lstinline$Ground$, \lstinline$Can$, and \lstinline$GrowBlock$ have dependencies. The matrix product state constructor functions \lstinline$CompMPS$, and \lstinline$ProdMPS$ are not shown as they are convenience functions which help to form part of the input to \lstinline$Ground$, but are not necessary to run the calculation. They both have only one dependency, on \lstinline$MPSNorm$. Note that the built-in functions of MATLAB \cite{MATLAB} are not considered, but almost all the functions written for the variational ground state search rely on them to some extent. They are assumed to operate properly.}
 \label{fig:vs2-1}
 \end{figure}
 
 \subsubsection{Ground}
 \paragraph{Docstring}
 This is the top-level function for the variational ground state search. Dependencies are \lstinline$Can$, \lstinline$ConvTest$, \lstinline$EffH$, \lstinline$Expect$, and \lstinline$SiteUpdate$. It is in principle the only function an end-user should have to deal with. Although mentioned here, explanation of the `standard format' of matrix product state used in this implementation is deferred until the main constructor function, \lstinline$CompMPS$, is described. The standard format of the matrix product operator used throughout this implementation is described here. Much of this function is devoted to book-keeping and reporting, though it does not produce a save file by itself except one after passing convergence threshold of \(1 \times 10^{-5}\). It does however, regularly output (hopefully) useful information to stdout. The rest of the function deals with the high level implementation of the variational search keeping track of what site is being updated, which direction the current sweep through the system is going, what the current energy of the system is, and how many sweeps have been completed. 
 \begin{lstlisting} 
 function [groundMPS, energyTracker] = Ground(init_mps, mpo, THRESHOLD, RUNMAX) \end{lstlisting}
 \begin{longtabu}{X[1,l]X[4,l]}
 \hline
 Return & \\ \hline
 \lstinline$groundMPS$ & \emph{\(N \times 1\) cell array}. Contains a matrix product state representing the approximate ground state of the system -- the solution state. Matrix product state is in the standard format used in this implementation. \\
 \lstinline$energyTracker$ & \emph{Dynamic 1-dimensional complex double array}. Begins with a single element, the energy of the initial state evaluated as \(\langle \Psi_{\mathrm{init}}^{\mathrm{MPS}} | \hat{H} | \Psi_{\mathrm{init}}^{\mathrm{MPS}} \rangle \). The energy of the system is evaluated after each full sweep, and the result is stored as \lstinline$energyTracker(end + 1)$ enlarging the array up to a maximum size of \lstinline$RUNMAX$\(+ 1\), in the case where the energy does not converge. This array is used to monitor for convergence.\\ \hline
 Input & \\ \hline
 \lstinline$init_mps$ & \emph{\(N \times 1\) cell array}. Contains some initial state in the standard matrix product format used in this implementation. \\
 \lstinline$mpo$ & \emph{\(3 \times 1\) cell array}. Contains a matrix product operator representation of a Hamiltonian. \lstinline$mpo\{1\}$ contains the first site matrix product operator, \lstinline$mpo\{3\}$ contains the last site matrix product operator, and \lstinline$mpo\{2\}$ contains the bulk site matrix product operator. Each is a two dimensional complex double array, formed from \(d \times d\) blocks, as advised in section 6.1 of Ref~\cite{Schollwoeck11}. The specific size will be dependent on the Hamiltonian being represented, but if \(P\) is the number of blocks required then \lstinline$mpo\{1\}$ will be \(d \times Pd\), \lstinline$mpo\{2\}$ will be \(Pd \times Pd\), and \lstinline$mpo\{3\}$ will be \(Pd \times d\). \\
 \lstinline$THRESHOLD$ & \emph{Double}. The threshold below which the energy of the system will be considered to have converged. Should be real, greater than numerical error (whatever that may be on the relevant hardware), and less than \(1 \times 10^{-7}\) since the code won't check against this value until the energy has converged to at least that level.\\
 \lstinline$RUNMAX$ & \emph{Double}. The maximum number of site updates that will be performed before the code finishes regardless of convergence. Take care that there are \(N\) site updates per \emph{sweep}. Should be an integer value (much) greater than zero. Essentially this value is used to stop the code iterating forever when a calculation does not converge to the desired level.\\
 \hline
 \end{longtabu}
 \paragraph{Testing}
 \lstinline$GroundTest$ \& \lstinline$MPO_on-site+hop.mat$. Tests function against different local state space sizes, system sizes, and amounts of compression. Standard size, shape, type testing of return values. Checks that \lstinline$groundMPS$ is normalised. Loads simple Hamiltonian matrix product operator from \lstinline$MPO_on-site+hop.mat$ and checks that function correctly finds the \(|0_{1}0_{2}\ldots 0_{N} \rangle\) ground state.
 \paragraph{Improvements}
 \begin{itemize}
 \item Function only creates a save file at the convergence to \(1 \times 10^{-5}\) checkpoint. It should probably do so at the \(1 \times 10^{-7}\) checkpoint, and full convergence as well. The checkpoint thresholds should be inputs, and ideally optional.
 \end{itemize}
 
 \subsubsection{CompMPS} 
 \paragraph{Docstring}
 This is a constructor function for a random matrix product state. This functionality is mainly useful for testing that other functions are not appearing to give correct results because of some property of the input state. Its only dependency is \lstinline$MPSNorm$. It accepts some basic parameters of the physical system, and returns a normalised matrix product state of the correct size and shape in the standard format. The standard format is an \(N \times 1\) cell array, where each cell contains a three-dimensional complex double array. The third index is the physical index for that particular site, and so should run from \(1\) to \(d\). The first two indices are the first and second virtual indices for a particular site. The virtual indices should grow as we move through the system, so that the first site should be a \(1 \times d \times d\) array, and the second a \(d \times d^{2} \times d\) array, and so on until the limit set by \lstinline$COMPRESS$ (\(\chi\)) is reached. At a certain point the virtual indices should begin shrinking again, such that the last site is a \(d \times 1 \times d\) array. This function and the other constructor, \lstinline$ProdMPS$ ensure this is the case.  
 \begin{lstlisting}
 function [complexMPS] = CompMPS(HILBY, L, COMPRESS) \end{lstlisting}
 \begin{longtabu}{X[1,l]X[4,l]}
 \hline
 Return & \\ \hline
 \lstinline$complexMPS$ & \emph{\lstinline$L$ \(\times 1\) cell array}. Contains a normalised matrix product state in the standard format with arrays that are at most \lstinline$COMPRESS$ \(\times\) \lstinline$COMPRESS$ \(\times\) \lstinline$HILBY$ in size. Each array is filled with random complex numbers generated using the MATLAB function \lstinline$rand$ in the form \lstinline$complexMPS\{site\} = rand(rowSize, colSize, HILBY) + 1i * rand(rowSize, colSize, HILBY)$. \\ \hline
 Input & \\ \hline
 \lstinline$HILBY$ & \emph{Double}. The size of the local state space, which we have previously referred to as \(d\). Should be a positive integer greater than 1.  \\
 \lstinline$L$ & \emph{Double}. The number of sites in the system, which we have previously referred to as \(N\). Should be a positive integer greater than 1. \\
 \lstinline$COMPRESS$ & \emph{Double}. The maximum allowed virtual dimension of the matrix prouct state tensors, which we have previously referred to as \(\chi_{\mathrm{max}}\). Note that if \lstinline$COMPRESS = 0$, it will be changed to the MATLAB value \lstinline$Inf$, meaning the matrix product state tensors will \emph{not} be compressed, and will reach a maximum size of \(d^{N/2}\).  \\
 \hline
 \end{longtabu}
 \paragraph{Testing}
 \lstinline$CompMPSTest$. Tests class, size, and shape of returned matrix product state. Uses a range of input values.
 \paragraph{Improvements}
 \begin{itemize}
 \item Testing should include checking that the returned matrix product state is properly normalised.
 \end{itemize}
 
 \subsubsection{ProdMPS}
 \paragraph{Docstring}
 This is a constructor function for a matrix product representation in the standard format of a simple product state. Its only dependence is \lstinline$MPSNorm$.
 \begin{lstlisting}
 function [matrices] = ProdMPS(stateArray, HILBY, COMPRESS) \end{lstlisting}
 \begin{longtabu}{X[1,l]X[4,l]}
 \hline
 Return & \\ \hline
 \lstinline$matrices$ & \emph{\(N \times 1\) cell array}. Contains a normalised matrix product state in the standard format, which represents the supplied product state. Formed by creating zero arrays of the correct size, and then replacing the appropriate matrices with the identity. \\ \hline
 Input & \\ \hline
 \lstinline$stateArray$ & \emph{\(N \times 1\) double array}. A column vector where each element refers to a particular site in the system, and contains the desired number state for that site. For example the three site state \(|1 1 0 \rangle\) would be supplied as \lstinline$[1; 1; 0]$. \\
 \lstinline$HILBY$ & \emph{Double}. The size of the local state space, which we have previously referred to as \(d\). Should be a positive integer greater than 1.  \\
 \lstinline$COMPRESS$ & \emph{Double}. The maximum allowed virtual dimension of the matrix prouct state tensors, which we have previously referred to as \(\chi_{\mathrm{max}}\). Note that if \lstinline$COMPRESS = 0$, it will be changed to the MATLAB value \lstinline$Inf$, meaning the matrix product state tensors will \emph{not} be compressed, and will reach a maximum size of \(d^{N/2}\).  \\
 \hline
 \end{longtabu}
 \paragraph{Improvements}
 \begin{itemize}
 \item Needs unit tests.
 \item Currently the code enforces that \lstinline$stateArray$ is a column vector, but there's no good reason for this.
 \end{itemize}
 
 \subsubsection{MPSNorm}
 \paragraph{Docstring}
 This function normalises a provided matrix product state. This is achieved by performing a QR decomposition on every site from the first, exactly as if one were making the state left-canonical. The major difference is that the final site in the system is also decomposed, and the final \(R\) matrix is discarded. In fact on the final site \(R\) is a scalar, equal to the norm of the state. Discarding it ensures that \(\langle \Psi | \Psi \rangle = 1\).
 \begin{lstlisting}
 function [normalMPS] = MPSNorm(mps) \end{lstlisting}
 \begin{longtabu}{X[1,l]X[4,l]}
 \hline
 Return & \\ \hline
 \lstinline$normalMPS$ & \emph{\(N \times 1\) cell array}. Contains the normalised form of the input matrix product state, \lstinline$mps$.  \\ \hline
 Input & \\ \hline
 \lstinline$mps$ & \emph{\(N \times 1\) cell array}. Some presumably un-normalised matrix product state, in the standard format. \\
 \hline
 \end{longtabu}
 \paragraph{Testing}
 \lstinline$MPSNormTest$. Builds matrix product states using a range of system sizes and levels of compression, and then normalises them. Rebuilds the state vector and and calculates \(\langle \Psi | \Psi \rangle\). 
 \paragraph{Improvements}
 \begin{itemize}
 \item \lstinline$MPSNormTest$ calls \lstinline$CompMPS$, a function which itself depends on \lstinline$MPSNorm$. This should be avoided if possible. 
 \item \lstinline$MPSNormTest$ rebuilds the entire state vector which is never efficient, and may be avoidable. Worse, it depends on the debug function \lstinline$Rebuild$ to do so. This should be changed.
 \end{itemize}
 
 \subsubsection{Can}
 \paragraph{Docstring} This function operates as an interface for the lower level matrix product state canonisation functions, \lstinline$LCan$, and \lstinline$RCan$ -- it is dependent on them. The most important task it performs is to check the supplied canonisation route ends at an appropriate place. If the system is being made left-canonical the last site in the route cannot be \(N\) as there is no `next site'. If the system is being made right-canonical, the last site in the route cannot be \(1\) for the same reason.
 \begin{lstlisting}
 function [cmps] = Can(mps, route, DIRECTION) \end{lstlisting}
 \begin{longtabu}{X[1,l]X[4,l]}
 \hline
 Return & \\ \hline
 \lstinline$cmps$ & \emph{\(N \times 1\) cell array}. Contains the canonical form of the input matrix product state, \lstinline$mps$.  \\ \hline
 Input & \\ \hline
 \lstinline$mps$ & \emph{\(N \times 1\) cell array}. Some matrix product state, in the standard format. \\
 \lstinline$route$ & \emph{1-dimensional double array}. Contains the site, or sites which are to be made canonical. May be as small as 1 element, or as large as \(N - 1\). All values should be integers larger than 0, and no larger than \(N\), and they should form a continuous route through the system -- \lstinline$[start : 1 : stop]$. If \lstinline$DIRECTION$ is \lstinline$'L'$ and \lstinline$route(end)$ is  \(N\), or if \lstinline$DIRECTION$ is \lstinline$'R'$ and \lstinline$route(end)$ is \(1\), then the route will be rejected and a warning will be printed to stdout.\\
 \lstinline$DIRECTION$ & \emph{Character}. Should be either \lstinline$'L'$, or \lstinline$'R'$. Specifies whether the sites should be made left- or right-canonical. \\
 \hline
 \end{longtabu}
 \paragraph{Improvements}
 \begin{itemize}
 \item Needs unit testing. Although \lstinline$CanTest$ exists, it really only tests \lstinline$LCan$ and \lstinline$RCan$, and nothing specific to \lstinline$Can$.
 \item Defensive if statements test whether \lstinline$route(end)$ is \(N\) or \(1\), but not any other incorrect values. A more comprehensive defence should be used.
 \item It may be better to use the MATLAB exception framework, rather than warnings printed to stdout.
 \end{itemize}
 
 \subsubsection{GrowBlock}
 \paragraph{Docstring} This function operates as an interface to the two lower level block formation functions, \lstinline$GrowLeft$ and \lstinline$GrowRight$. It is dependent on them. When called it adds a given site tensor into either a left or right block tensor, returning either \(L^{[n+1]}\) or \(R^{[n-1]}\). It's main purpose is to keep the function call required to grow a left or right block more simple by checking the size of the matrix product state site tensor, and the matrix product operator tensor in order to generate some of the constants that \lstinline$GrowLeft$ and \lstinline$GrowRight$ require. It also ensures the correct matrix product state, and left or right block tensors are used.
 \begin{lstlisting}
 function [updateBlock] = GrowBlock(mps, mpo, TARGET, SIDE, blockCell) \end{lstlisting}
 \begin{longtabu}{X[1,l]X[4,l]}
 \hline
 Return & \\ \hline
 \lstinline$updateBlock$ & \emph{3-dimensional complex double array}. The left or right block tensor \(L^{[n+1]}\) or \(R^{[n-1]}\) from \cref{eq:vs1-4,eq:vs1-5}, where \(n\) is \lstinline$TARGET$. \\ \hline
 Input & \\ \hline
 \lstinline$mps$ & \emph{\(N \times 1\) cell array}. Some matrix product state, in the standard format. \\
 \lstinline$mpo$ & \emph{\(3 \times 1\) cell array}. A matrix product operator representation of a Hamiltonian, in the standard format. \\
 \lstinline$TARGET$ & \emph{Double}. The site which is to be included in the left or right block. Note that the left block tensor \(L^{[n]}\) does not include the site tensor \(A^{[n]}\), \emph{only} \(A^{[1]} \ldots A^{[n-1]}\). Similarly, \(R^{[n]}\) does not include \(A^{[n]}\), only \(A^{[n+1]} \ldots A^{[N]}\). Should be an integer value greater than 0 and no greater than \(N\). \\
 \lstinline$SIDE$ & \emph{Character}. Should be either \lstinline$'L'$, or \lstinline$'R'$. Specifies whether the left or right block is being updated. \\
 \lstinline$blockCell$ & \emph{\(N \times 1\) cell array}. Contains all of the \(L^{[n]}\) or \(R^{[n]}\) arrays in the format \lstinline$blockCell\{n\}$. \\
 \hline
 \end{longtabu}
 \paragraph{Improvements}
 \begin{itemize}
 \item Needs unit testing.
 \item Should defend against bad values of \lstinline$TARGET$ and if possible \lstinline$blockCell$.
 \end{itemize}
 
 \subsubsection{ConvTest}
 \paragraph{Docstring} This function tests to see if the energy of the system has converged. Exactly what `converged' means is configurable by the input parameters. The latest observed energy is subtracted from the last \lstinline$sampleSize$ observed energies. The largest absolute value resulting from this is compared against \lstinline$threshold$. If it is smaller, then a true flag is returned.
 \begin{lstlisting}
 function [convFlag] = ConvTest(energyTracker, sampleSize, threshold) \end{lstlisting}
 \begin{longtabu}{X[1,l]X[4,l]}
 \hline
 Return & \\ \hline
 \lstinline$convFlag$ & \emph{Double}. MATLAB doesn't use Boolean datatypes. Instead a non-zero double will evaluate as true, and \(0\) will evaluate as false. As such, \lstinline$convFlag$ will be returned as \(1\) if the convergence test is passed, and will be returned as \(0\) otherwise. \\ \hline
 Input & \\ \hline
 \lstinline$energyTracker$ & \emph{1-dimensional complex double array}. Contains the observed energies of the system, calculated by evaluating \(\langle \Psi | \hat{H} | \Psi \rangle\) by contracting the system as shown in \cref{fig:vs1-2}. This array changes size throughout the calculation, but is fixed at time of input to this function. It may be as small as \(1 \times 1\), or as large as \lstinline$RUNMAX$\( \times 1\). If it is smaller than \lstinline$sampleSize$\(\times 1\), then \lstinline$ConvTest$ will just return \lstinline$convFlag = 1$. \\
 \lstinline$sampleSize$ & \emph{Double}. The number of energies which will be compared to test for convergence. It should be an integer, and should obviously be less than \lstinline$RUNMAX$, however be cautioned that setting it too low will result in the energy `converging' while undergoing oscillation. It is worth inspecting \lstinline$energyTracker$ to make sure this is not the case. \\
 \lstinline$threshold$ & \emph{Double}. The threshold against which the energy's convergence will be tested. For the convergence test to return true, the absolute value of the energy of the system will not have changed by more than \lstinline$threshold$ in the last \lstinline$sampleSize$ iterations of the variational procedure. \\
 \hline
 \end{longtabu}
 \paragraph{Testing}
 \lstinline$ConvTestTest$. Throws a variety of fabricated \lstinline$energyTracker$ arrays and parameters at \lstinline$ConvTest$, and asserts that they should return 1 or 0. Looks for false positives on both undersampled, and non-converged energies.
 \paragraph{Improvements}
 \begin{itemize}
 \item There may be a more sophisticated way to test for convergence. 
\end{itemize}  

 \subsubsection{EffH}
 \paragraph{Docstring} This function calculates the effective Hamiltonian for a particular site in the system, using \cref{eq:vs1-9} which is visualised in \cref{fig:vs1-3}. In fact it returns the rank-6 tensor already reshaped into a matrix, and ready to be eigensolved.
 \begin{lstlisting}
 function [effectiveHamiltonian] = EffH(HILBY, rowMax, colMax, leftBlock, mpoTensor, rightBlock) \end{lstlisting}
 \begin{longtabu}{X[1,l]X[2,l]}
 \hline
 Return & \\ \hline
 \lstinline$effectiveHamiltonian$ & \emph{2-dimensional complex double array}. The rank-6 effective Hamiltonian tensor for site \(n\), \(\hat{H}_{\mathrm{eff}}^{[n]}\) formed by the contraction shown in \cref{eq:vs1-9}, and visualised in \cref{fig:vs1-3}. The tensor is reshaped in to a matrix, with dimensions equal to the square of the number of elements in the matrix product state tensor for site \(n\) -- (\lstinline$HILBY$\( \times \)\lstinline$rowMax$\( \times \)\lstinline$colMax$) \(\times\) (\lstinline$HILBY$\( \times \)\lstinline$rowMax$\( \times \)\lstinline$colMax$). The eigenvector of this matrix with the smallest real eigenvalue can be reshaped to replace \(A^{[n]}\). \\ \hline
 Input & \\ \hline
 \lstinline$HILBY$ & \emph{Double}. The size of the local state space, which we have previously referred to as \(d\). Should be a positive integer greater than 1. \\
 \lstinline$rowMax$ & \emph{Double}. The size of the first virtual dimension of the matrix product state tensor for site \(n\), \(A^{[n]}\). Should be a positive integer. Will range between 1 and \(\chi_{\mathrm{max}}\).\\
 \lstinline$colMax$ & \emph{Double}. The size of the second virtual dimension of the matrix product state tensor for site \(n\), \(A^{[n]}\). Should be a positive integer. Will range between 1 and \(\chi_{\mathrm{max}}\).\\
 \lstinline$leftBlock$ & \emph{3-dimensional complex double array}. The rank-3 left block tensor for site \(n\), \(L^{[n]}\). Contains the contraction of the the expectation over the Hamiltonian from the first site, up to the site \(n-1\), as shown in \cref{eq:vs1-4}.\\
 \lstinline$mpoTensor$ & \emph{2-dimensional complex double array}. The relevant matrix product operator tensor for the site \(n\), \(\hat{O}^{[n]}\). A rank-4 tensor, but the format used throughout this code is a matrix, formed from \(d \times d\) blocks, which are indexed by the tensor's virtual indices.\\
 \lstinline$rightBlock$ & \emph{3-dimensional complex double array}. The rank-3 right block tensor for site \(n\), \(R^{[n]}\). Contains the contraction of the the expectation over the Hamiltonian up to the site \(n+1\), from the last site, as shown in \cref{eq:vs1-5}.\\
 \hline
 \end{longtabu}
 \paragraph{Testing}
 \lstinline$EffHTest$ \& \lstinline$MPO_on-site+hop.mat$. Forms a random uncompressed nine qubit matrix product state, and uses the Hamiltonian matrix product operator from \lstinline$MPO_on-site+hop.mat$. Forms the effective Hamiltonian at each site, and checks that it is Hermitian. 
 \paragraph{Improvements} 
 \begin{itemize}
 \item The contraction and the reshape should be two separate functions. This function \emph{has} been optimised, but as a result is almost impossible to read and understand, and combining the contraction with the reshape to a matrix doesn't help that. 
 \item Some way of testing that the effective Hamiltonian was right would certainly help. 
 \end{itemize}
 
 \subsubsection{Expect}
 \paragraph{Docstring} This function calculates the expectation value of the Hamiltonian, \(\langle \Psi_{\mathrm{MPS}} | \hat{H} | \Psi_{\mathrm{MPS}} \rangle\). It performs a contraction using the left and right block tensors, and the matrix product state site tensors for a single site, in the manner visualised in \cref{fig:vs1-2}. In general this function performs best on the first and last site, as the dimensions are reduced.
 \begin{lstlisting}
 function [expectationValue] = Expect(mps, mpo, leftBlock, rightBlock, TARGET) \end{lstlisting}
 \begin{longtabu}{X[1,l]X[3,l]}
 \hline
 Return & \\ \hline
 \lstinline$expectationValue$ & \emph{Complex double}. This is the expectation value \(\langle \Psi | \hat{H} | \Psi \rangle\). Although it is evaluated `at a site', it is the expectation value for the whole system. The \lstinline$leftBlock$ and \lstinline$rightBlock$ contain contractions through to either side of the target site. Using the already contracted left and right blocks is considerably faster than always contracting through the entire system. This function is called after every site update in order to monitor the energy of the system for convergence.  \\ \hline
 Input & \\ \hline
 \lstinline$mps$ & \emph{\(N \times 1\) cell array}. Some matrix product state, in the standard format. \\
 \lstinline$mpo$ & \emph{\(3 \times 1\) cell array}. A matrix product operator of a Hamiltonian, in the standard format.\\
 \lstinline$leftBlock$ & \emph{3-dimensional complex double array}. The rank-3 left block tensor for site \(n\), \(L^{[n]}\). Contains the contraction of the the expectation over the Hamiltonian from the first site, up to the site \(n-1\), as shown in \cref{eq:vs1-4}.\\
 \lstinline$rightBlock$ & \emph{3-dimensional complex double array}. The rank-3 right block tensor for site \(n\), \(R^{[n]}\). Contains the contraction of the the expectation over the Hamiltonian up to the site \(n+1\), from the last site, as shown in \cref{eq:vs1-5}. \\
 \lstinline$TARGET$ & \emph{Double}. The site \(n\) at which the contraction to calculate \(\langle \Psi | \hat{H} | \Psi \rangle\) is to be completed. Can be any integer from \(1\) to \(N\), but should match with \lstinline$leftBlock$ and \lstinline$rightBlock$. In the context of the variational search, this is evaluated at the site on which an update has just been performed in order to calculate the new energy of the system. \\
 \hline
 \end{longtabu}
 \paragraph{Testing} \lstinline$ExpectTest$. Builds random matrix product states using a range of local Hilbert space sizes, system sizes, and levels of compression. Calculates the expectation value of the identity operator -- the norm of the state -- and asserts that it is \(1\). This works as long as the state is properly normalised.
 \paragraph{Improvements}
 \begin{itemize}
 \item Some defense against using left and right blocks that did not relate to the correct site. Currently the calculation would fail if the sites happened to have different size matrices, otherwise it just outputs the wrong answer.
 \item \lstinline$ExpectTest$ does not normalise the matrix product states, but assumes that they are normalised. Changing this may of course introduce an unwanted dependence on \lstinline$MPSNorm$. 
 \item \lstinline$ExpectTest$ always evaluates the \(\langle \Psi | \mathbb{I} | \Psi \rangle\) at the central site. It would be good to verify that the evaluation returned the same result when performed at different sites.
 \end{itemize} 
 
 \subsubsection{GrowLeft}
 \paragraph{Docstring} This is a low-level function interfaced by \lstinline$GrowBlock$. It is responsible for contracting a matrix product site tensor, \(A^{[n]}\), into a left block tensor \(L^{[n]}\) in order to find the left block tensor \(L^{[n+1]}\). It implements the contraction shown in \cref{eq:vs1-4}. 
 \begin{lstlisting}
 function [updateBlock] = GrowLeft(siteTensor, mpoTensor, leftBlock, rowMax, colMax, HILBY, opRowMax, opColMax, OPCOUNT) \end{lstlisting}
 \begin{longtabu}{X[1,l]X[4,l]}
 \hline
 Return & \\ \hline
 \lstinline$updateBlock$ & \emph{3-dimensional complex double array}. The left block tensor for the site \(n+1\), \(L^{[n+1]}\). \\ \hline
 Input & \\ \hline
 \lstinline$siteTensor$ & \emph{3-dimensional complex double array}. The matrix product state tensor for the site \(n\), in the standard format. \\
 \lstinline$mpoTensor$ & \emph{2-dimensional complex double array}. The matrix product operator tensor for the site \(n\), in the standard format. \\
 \lstinline$leftBlock$ & \emph{3-dimensional complex double array}. The rank-3 left block tensor for site \(n\), \(L^{[n]}\). Contains the contraction of the the expectation over the Hamiltonian from the first site, up to the site \(n-1\), as shown in \cref{eq:vs1-4}. \\
 \lstinline$rowMax$ & \emph{Double}. The size of the first virtual dimension of the matrix product state tensor for site \(n\), \(A^{[n]}\). Should be a positive integer. Will range between 1 and \(\chi_{\mathrm{max}}\).\\
 \lstinline$colMax$ & \emph{Double}. The size of the second virtual dimension of the matrix product state tensor for site \(n\), \(A^{[n]}\). Should be a positive integer. Will range between 1 and \(\chi_{\mathrm{max}}\).\\
 \lstinline$HILBY$ & \emph{Double}. The size of the local state space, which we have previously referred to as \(d\). Should be a positive integer greater than 1. \\
 \lstinline$opRowMax$ & \emph{Double}. The size of the first virtual dimension of the matrix product operator tensor for site \(n\), \(\hat{O}^{[n]}\), \emph{when indexed from zero}. Should be a positive integer. Indexed from zero in this case as it is used to generate a linear index. \\
 \lstinline$opColMax$ & \emph{Double}. The size of the second virtual dimension of the matrix product operator tensor for site \(n\), \(\hat{O}^{[n]}\), \emph{when indexed from zero}. Should be a positive integer. Indexed from zero in this case as it is used to generate a linear index. \\
 \lstinline$OPCOUNT$ & \emph{Double}. The larger of \lstinline$opRowMax$ and \lstinline$opColMax$ plus one. The maximum virtual dimension of the matrix product operator tensor for site \(n\), \(\hat{O}^{[n]}\), \emph{when indexed from one}. Should be a positive integer. \\
 \hline
 \end{longtabu}
 \paragraph{Improvements}
 \begin{itemize}
 \item Needs unit testing.
 \end{itemize}
 
 \subsubsection{GrowRight}
 \paragraph{Docstring} This is a low-level function interfaced by \lstinline$GrowBlock$. It is responsible for contracting a matrix product site tensor, \(A^{[n]}\), into a right block tensor \(R^{[n]}\) in order to find the right block tensor \(R^{[n-1]}\). It implements the contraction shown in \cref{eq:vs1-5}. 
 \begin{lstlisting}
 function [updateBlock] = GrowRight(siteTensor, mpoTensor, rightBlock, rowMax, colMax, HILBY, opRowMax, opColMax, OPCOUNT) \end{lstlisting}
 \begin{longtabu}{X[1,l]X[4,l]}
 \hline
 Return & \\ \hline
 \lstinline$updateBlock$ & \emph{3-dimensional complex double array}. The right block tensor for the site \(n-1\), \(R^{[n-1]}\). \\ \hline
 Input & \\ \hline
 \lstinline$siteTensor$ & \emph{3-dimensional complex double array}. The matrix product state tensor for the site \(n\), in the standard format. \\
 \lstinline$mpoTensor$ & \emph{2-dimensional complex double array}. The matrix product operator tensor for the site \(n\), in the standard format. \\
 \lstinline$rightBlock$ & \emph{3-dimensional complex double array}. The rank-3 right block tensor for site \(n\), \(R^{[n]}\). Contains the contraction of the the expectation over the Hamiltonian from the last site, to the site \(n+1\), as shown in \cref{eq:vs1-5}. \\
 \lstinline$rowMax$ & \emph{Double}. The size of the first virtual dimension of the matrix product state tensor for site \(n\), \(A^{[n]}\). Should be a positive integer. Will range between 1 and \(\chi_{\mathrm{max}}\).\\
 \lstinline$colMax$ & \emph{Double}. The size of the second virtual dimension of the matrix product state tensor for site \(n\), \(A^{[n]}\). Should be a positive integer. Will range between 1 and \(\chi_{\mathrm{max}}\).\\
 \lstinline$HILBY$ & \emph{Double}. The size of the local state space, which we have previously referred to as \(d\). Should be a positive integer greater than 1. \\
 \lstinline$opRowMax$ & \emph{Double}. The size of the first virtual dimension of the matrix product operator tensor for site \(n\), \(\hat{O}^{[n]}\), \emph{when indexed from zero}. Should be a positive integer. Indexed from zero in this case as it is used to generate a linear index. \\
 \lstinline$opColMax$ & \emph{Double}. The size of the second virtual dimension of the matrix product operator tensor for site \(n\), \(\hat{O}^{[n]}\), \emph{when indexed from zero}. Should be a positive integer. Indexed from zero in this case as it is used to generate a linear index. \\
 \lstinline$OPCOUNT$ & \emph{Double}. The larger of \lstinline$opRowMax$ and \lstinline$opColMax$ plus one. The maximum virtual dimension of the matrix product operator tensor for site \(n\), \(\hat{O}^{[n]}\), \emph{when indexed from one}. Should be a positive integer. \\
 \hline
 \end{longtabu}
 \paragraph{Improvements}
 \begin{itemize}
 \item Needs unit testing.
 \end{itemize}
 
 \subsubsection{LCan}
 \paragraph{Docstring} This is a low-level function interfaced by \lstinline$Can$. It is responsible for renormalising a site tensor, or continuous set of site tensors so that they are left-canonical. This is achieved using a QR decomposition, as it is faster than an SVD decomposition. The site tensor \(A^{[n]}\) is reshaped to form the matrix \(M\) which is decomposed as \(M=QR\). The \(Q\) matrix is reshaped to replace the site tensor \(A^{[n]}\), and \(R\) is multiplied in to the next site tensor along, \(A^{[n+1]}\).
 \begin{lstlisting}
 function [lmps] = LCan(mps, route) \end{lstlisting}
 \begin{longtabu}{X[1,l]X[4,l]}
 \hline
 Return & \\ \hline
 \lstinline$lmps$ & \emph{\(N \times 1\) cell array}. A matrix product state in the standard format, with sites along the specified route made left-canonical. \\ \hline
 Input & \\ \hline
 \lstinline$mps$ & \emph{\(N \times 1\) cell array}. A matrix product state, in the standard format. \\
 \lstinline$route$ & \emph{1-dimensional double array}. Contains the site, or sites which are to be made canonical. May be as small as 1 element, or as large as \(N - 1\). All values should be integers larger than 0, and less than \(N\), and they should form a continuous route through the system -- \lstinline$[start : 1 : stop]$. \\
 \hline
 \end{longtabu}
 \paragraph{Testing}
 \lstinline$CanTest.m$. Creates random matrix product states using a range of local state space sizes, system sizes, and levels of compression. Checks that using \lstinline$LCan$ does not affect the norm of the matrix product state, and does not change the state it represents.
 \paragraph{Improvements}
 \begin{itemize}
 \item \lstinline$CanTest$ relies on the debug function \lstinline$Rebuild$ to check state does not change -- this is not ideal. Instead of rebuilding the entire state vector, elements from it could be sampled.
 \end{itemize}

 \subsubsection{RCan}
 \paragraph{Docstring} This is a low-level function interfaced by \lstinline$Can$. It is responsible for renormalising a site tensor, or continuous set of site tensors so that they are right-canonical. The site tensor \(A^{[n]}\) is reshaped into the matrix \(M\) which is decomposed as \(M = USV^{\dagger}\). The unitary matrix \(V^{\dagger}\) is reshaped to form the new site tensor \(A^{[n]}\), and \(US\) is multiplied in to the next site tensor along, \(A^{[n-1]}\).
 \begin{lstlisting}
 function [rmps] = RCan(mps, route) \end{lstlisting}
 \begin{longtabu}{X[1,l]X[4,l]}
 \hline
 Return & \\ \hline
 \lstinline$rmps$ & \emph{\(N \times 1\) cell array}. A matrix product state in the standard format, with sites along the specified route made right-canonical. \\ \hline
 Input & \\ \hline
 \lstinline$mps$ & \emph{\(N \times 1\) cell array}. A matrix product state, in the standard format. \\
 \lstinline$route$ & \emph{1-dimensional double array}. Contains the site, or sites which are to be made canonical. May be as small as 1 element, or as large as \(N - 1\). All values should be integers larger than 1, and no larger than \(N\), and they should form a continuous route through the system -- \lstinline$[start : -1 : stop]$. \\
 \hline
 \end{longtabu}
 \paragraph{Testing}
  \lstinline$CanTest.m$. Creates random matrix product states using a range of local state space sizes, system sizes, and levels of compression. Checks that using \lstinline$RCan$ does not affect the norm of the matrix product state, and does not change the state it represents.
  \paragraph{Improvements}
  \begin{itemize}
  \item The QR decomposition is considerably faster than the SVD, and could be used here instead.
  \item \lstinline$CanTest$ relies on the debug function \lstinline$Rebuild$ to check state does not change -- this is not ideal. Instead of rebuilding the entire state vector, elements from it could be sampled.
  \end{itemize}
  
 \subsubsection{SiteUpdate}
 \paragraph{Docstring} A very simple function that takes an eigenvector of \(H^{[n]}_{\mathrm{eff}}\) and reshapes it to form the new rank-3 site tensor, \(A^{[n]}\). 
 \begin{lstlisting}
 function [updateMatrix] = SiteUpdate(eigVec, rowMax, colMax, HILBY) \end{lstlisting}
 \begin{longtabu}{X[1,l]X[4,l]}
 \hline
 Return & \\ \hline
 \lstinline$updateMatrix$ & \emph{3-dimensional complex double array}. The new rank-3 site tensor \(A^{[n]}\). \\ \hline
 Input & \\ \hline
 \lstinline$eigVec$ & \emph{1-dimensional complex double array}. An eigenvector of the effective Hamiltonian for the site \(n\). Must have dimension \lstinline$rowMax$\(\times\)\lstinline$colMax$\(\times\)\lstinline$HILBY$. \\
 \lstinline$rowMax$ & \emph{Double}. The size of the first virtual dimension of the matrix product state tensor for site \(n\), \(A^{[n]}\). Should be a positive integer. Will range between 1 and \(\chi_{\mathrm{max}}\).\\
 \lstinline$colMax$ & \emph{Double}. The size of the second virtual dimension of the matrix product state tensor for site \(n\), \(A^{[n]}\). Should be a positive integer. Will range between 1 and \(\chi_{\mathrm{max}}\).\\
 \lstinline$HILBY$ & \emph{Double}. The size of the local state space, which we have previously referred to as \(d\). Should be a positive integer greater than 1. \\
 \hline
 \end{longtabu}
 
\FloatBarrier 
 
 \subsection{Stationary State Implementation}
 
 \begin{figure}[ht!]
 \centering
 \includegraphics[width=0.8\linewidth]{\figpath/mpostat}
 \caption{A diagram showing the structure of the variational stationary state search code. Each rectangle is a function, with it's size indicating position in the program hierarchy. The largest are \emph{top level} functions which are intended to be called by the user, the medium sized are \emph{core} functions which are interface functions to the smallest squares, the \emph{utility} functions. The arrows represent calls and returns, with the return direction indicated by the arrow head i.e. \lstinline$Stationary$ calls \lstinline$GrowBlock$ and \lstinline$GrowBlock$ returns values to \lstinline$Stationary$. }
 \label{fig:vs2-2}
 \end{figure} 
 
 We will now discuss the variational stationary state search. The implementation is also written for MATLAB \cite{MATLAB}, and at the time of writing is held in a git repository hosted at Ref~\cite{otb:gitVSSS}. In this section we will use the conventions that \(N\) is the number of sites in our system, and \(d\) is the dimension of the local state space, so the total state space of our system would be \(d^{N}\), and the full density matrix has \(d^{2N}\) elements. \Cref{fig:vs2-2} shows the structure of the code diagramatically. The principle difference between this and the ground state search code, is that our matrix product state now has two physical indices, \(|i \rangle \langle j |\), and our matrix product operator has four. To make the dsitinction clear, we refer to the matrix product state as a `density matrix product operator'. In order to write this code I referred to the ever useful Ref~\cite{Schollwoeck11}, and also to two more recent papers which dealt specifically with variational stationary state searches \cite{CCB15,MFS15}. Finally, we note that this code makes use of an external library, the PRIMME eigensolver \cite{SM10,WRS16}.
 
 \subsubsection{PhasedSearch}
 \paragraph{Docstring} This is a top-level function for the variational stationary state search. Dependencies are \lstinline$MixDMPO$, \lstinline$Stationary$, and \lstinline$DMPOResize$. It takes basic information about the system which is to be solved, including the matrix product operator, an accuracy threshold for the eigenvalue, a maximum allowed matrix dimension, and which variant of the calculation is to be performed. The function has two return values -- a DMPO which approximates the stationary state of the system, and a vector containing the eigenvalue recorded at the end of each \emph{phase} of the calculation. This terminology is borrowed from sports (a phase of play), and here describes the process of finding the stationary state of the system using a DMPO of some particular dimension. At the end of the calculation the eigenvalue is evaluated against the desired accuracy threshold and if it is not close enough to zero the current state is copied to a DMPO representation with a larger matrix dimension (as long as this can be done without breaching a limit set by the user). The available variants are \lstinline$direct$ which solves the Liouvillian, \(\hat{\mathcal{L}}\), \lstinline$hermitian$ which solves the Hermitian product of the Liouvillian, \(\hat{\mathcal{L}}^{\dagger}\hat{\mathcal{L}}\), and \lstinline$primme$ which solves the Hermitian problem using the PRIMME eigensolver \cite{SM10,WRS16}. The user is expected to provide the appropriate MPO for the variant they specify, but an error will be thrown if you try to run a Hermitian calculation with the MPO for \(\hat{\mathcal{L}}\). The reverse is not checked on the basis that finding the MPO of the Hermitian product of the Liouvillian involves an additional computational step which the end user is unlikely to invoke accidentally.

 \begin{lstlisting}
 function [dmpoStat, phaseTrack] = PhasedSearch(HILBY, LENGTH, mpo, ULTIMATE_THRESHOLD, MAX_COMPRESS, VARIANT)
 \end{lstlisting} 
 \begin{longtabu}{X[1,1]X[4,1]}
 \hline
 Return & \\ \hline
 \lstinline$dmpoStat$ & \emph{\(N \times 1\) cell array}. Contains a density matrix product operator representing the approximate stationary state of the system. DMPO is in the standard format used in this implementation. \\
 \lstinline$phaseTrack$ & \emph{Complex double array}. Contains the eigenvalue recorded at the end of each phase of the calculation. If the last entry is less than the threshold set by the user then the calculation is regarded as having been successful. \\ \hline
 Input & \\ \hline
 \lstinline$HILBY$ & \emph{Double}. The size of the local state space, \(d\). Should be a positive integer, greater than one. \\
 \lstinline$LENGTH$ & \emph{Double}. The number of sites in the system, \(N\). Should be a positive integer greater than one. \\
 \lstinline$mpo$ & \emph{\(N \times 1\) cell array}. Liouvillian for the system in matrix product operator form. It is important that the supplied Liouvillian matches the requested calculation variant. If the user requests the Hermitian calculation variant is requested, then the mpo should represent the hermitian product Liouvillian \(\mathcal{L}^{\dagger}\mathcal{L}\), or the \lstinline$EigenSolver$ function will throw an error. \\
 \lstinline$ULTIMATE_THRESHOLD$ & \emph{Double}. The desired final accuracy, as determined by the residual \(|\mathcal{L}\rho - 0|\), or \(|\mathcal{L}^{\dagger}\mathcal{L}\rho - 0|\) in the Hermitian case. The calculation will end and return the results once it crosses this threshold (if it crosses this threshold). \\
 \lstinline$MAX_COMPRESS$ & \emph{Double}. The maximum allowed DMPO matrix dimension, \(\chi\). Should be a positive integer greater than or equal to the square of the local state space, \(d^{2}\). \\
 \lstinline$VARIANT$ & \emph{String}. Specifies the form and method of the calculation. There are three options: `\lstinline$direct$', `\lstinline$hermitian$', and `\lstinline$primme$'. If `\lstinline$direct$' is supplied, the non-Hermitian Liouvillian \(\mathcal{L}\) is solved using MATLAB's sparse eigensolver, \lstinline$eigs$. If `\lstinline$hermitian$' or `\lstinline$primme$' is supplied, the Hermitian product of the Liouvillian \(\mathcal{L}^{\dagger}\mathcal{L}\) is solved using the \lstinline$eigs$ and PRIMME eigensolvers respectively. Additionally, if `\lstinline$hermitian$' is supplied, but \lstinline$eigs$ fails to find a solution on some site, a second attempt will be made using the PRIMME eigensolver. \\
 \hline 
 \end{longtabu}
 
 \paragraph{Testing}
 \lstinline$PhasedSearchTest$. Checks that an error is thrown if the Hermiticity error in the effective Liouvillian is large -- this is a symptom of having supplied an MPO for the Liouvillian operator \(\mathcal{L}\), but requested the Hermitian problem be solved. Checks that the two return values are the right size, shape and class. Checks that for all three calculation variants, the trace of the solution density matrix is one, and that the eigenvalue is as close to zero as it ought to be (i.e. that it is less than \lstinline$ULTIMATE_THRESHOLD$). The supplied test problem has the trivial stationary state of no occupation in any site (the `all-zero' state), it is checked that the solution density matrix has a 1 in this state, and other elements are sampled and checked for erroneous non-zero values.
 
 \subsubsection{Stationary}
 \paragraph{Docstring} This is a top-level function for the variational stationary state search. Dependencies are \lstinline$Can$, \lstinline$GrowBlock$, \lstinline$EffL$, \lstinline$EigenSolver$, \lstinline$ConvTest$, and \lstinline$TrNorm$. It takes information about the system to be solved, and returns an approximation to the stationary state in density matrix product operator form. The difference between this and the \lstinline$PhasedSearch$ top-level function is that \lstinline$Stationary$ will try to solve the problem using the supplied matrix dimension and will either succeed, or fail -- it will \emph{not} attempt any resizing of the DMPO. In fact during each phase \lstinline$PhasedSearch$ calls \lstinline$Stationary$ with either a lower accuracy threshold, or a larger matrix dimension. In the event that \lstinline$Stationary$ fails to reach the specified threshold it will print a message to stdout, and return the current state. 
 
 \begin{lstlisting}
 function [dmpoStat, eigTrack] = Stationary(dmpoInit, mpo, THRESHOLD, variant)
 \end{lstlisting}
 \begin{longtabu}{X[1,1]X[4,1]}
 \hline
 Return & \\ \hline
 \lstinline$dmpoStat$ & \emph{\(N \times 1\) cell array}. Contains a density matrix product operator representing the approximate stationary state of the system. DMPO is in the standard format used in this implementation. \\
 \lstinline$eigTrack$ & \emph{Complex double array}. Contains the eigenvalues from the last \(2(N-1)\) site updates. These eigenvalues are tested for convergence after each update, and if the last element is lower than the threshold set by the user, then the calculation is regarded as having been successful. \\ \hline
 Input & \\ \hline
 \lstinline$dmpoInit$ & \emph{\(N \times 1\) cell array}. Contains some initial density matrix product operator. The closer this is to the stationary state, the faster the calculation will converge. The matrix dimensions of this input DMPO determine the matrix dimensions of the output DMPO, \lstinline$dmpoStat$.  \\
 \lstinline$mpo$ & \emph{\(N \times 1\) cell array}. Liouvillian for the system in matrix product operator form. It is important that the supplied Liouvillian matches the requested calculation variant. If the user requests the Hermitian calculation variant is requested, then the mpo should represent the hermitian product Liouvillian \(\mathcal{L}^{\dagger}\mathcal{L}\), or the \lstinline$EigenSolver$ function will throw an error.\\
 \lstinline$THRESHOLD$ & \emph{Double}. The desired final accuracy, as determined by the residual \(|\mathcal{L}\rho - 0|\), or \(|\mathcal{L}^{\dagger}\mathcal{L}\rho - 0|\) in the Hermitian case. The calculation will end and the return the results once it crosses this threshold (if it crosses this threshold). \\
 \lstinline$variant$ & emph{String}. Specifies the form and method of the calculation. There are three options: `\lstinline$direct$', `\lstinline$hermitian$', and `\lstinline$primme$'. If `\lstinline$direct$' is supplied, the non-Hermitian Liouvillian \(\mathcal{L}\) is solved using MATLAB's sparse eigensolver, \lstinline$eigs$. If `\lstinline$hermitian$' or `\lstinline$primme$' is supplied, the Hermitian product of the Liouvillian \(\mathcal{L}^{\dagger}\mathcal{L}\) is solved using the \lstinline$eigs$ and PRIMME eigensolvers respectively. Additionally, if `\lstinline$hermitian$' is supplied, but \lstinline$eigs$ fails to find a solution on some site, a second attempt will be made using the PRIMME eigensolver. \\
 \hline
 \end{longtabu}
 
 \paragraph{Testing} \lstinline$StationaryTest$. Checks that the two return values are the right size, shape, and class. Checks that errors are thrown in the event that a bad \lstinline$variant$ is supplied, or if a non-Hermitian MPO is supplied with a Hermitian variant. Checks that for all three calculation variants the returned stationary state has a trace of one, and is in the correct state, and that the final eigenvalue is less than \lstinline$THRESHOLD$. 
 
 \subsubsection{DDMPO}
 \paragraph{Docstring} This is a constructor function for a density matrix product operator. It creates a density matrix product operator which represents a normalised density matrix with the same real value in every element. For example, for a two qubit system \lstinline$DDMPO$ would create a density matrix product operator corresponding to the density matrix,
 \begin{equation}
 \rho = \begin{pmatrix}
 0.25 & 0.25 & 0.25 & 0.25 \\
 0.25 & 0.25 & 0.25 & 0.25 \\
 0.25 & 0.25 & 0.25 & 0.25 \\
 0.25 & 0.25 & 0.25 & 0.25 \end{pmatrix}.
 \label{eq:vs3-4}
 \end{equation} 
 This function depends on \lstinline$DMPOScalarDiv$.
 \begin{lstlisting}
 function [dmpo] = DDMPO(HILBY, LENGTH, COMPRESS) \end{lstlisting}
 \begin{longtabu}{X[1,l]X[4,l]}
 \hline
 Return & \\ \hline
 \lstinline$dmpo$ & \emph{\(N \times 1\) cell array}. A density matrix productor operator in the standard format. Created by making the first element in every matrix \(A^{[n]}_{i,j}\) one, with the rest all zeroes. The density matrix product operator is then divided by \(d^{N}\).  \\ \hline
 Input & \\ \hline
 \lstinline$HILBY$ & \emph{Double}. The size of the local state space, \(d\). Should be a positive integer, greater than 1. \\
 \lstinline$LENGTH$ & \emph{Double}. The number of sites in the system, \(N\). Should be a positive integer, greater than 1. \\
 \lstinline$COMPRESS$ & \emph{Double}. The maximum size, \(\chi_{\mathrm{max}}\) of the virtual dimensions of the density matrix product state site tensors, \(A^{[n]}\). If \lstinline$COMPRESS == 0$, it will be set to \lstinline$Inf$, leaving the density matrix product operator uncompressed. Should be a positive integer either equal to zero, or greater than or equal to \(d^{2}\). If \(0 <\) \lstinline$COMPRESS$ \(< d^{2}\) an error will be thrown. \\
 \hline
 \end{longtabu}  
 \paragraph{Testing} \lstinline$DDMPOTest$. Checks the type, size, and shape of the density matrix product operator. It checks that compression is properly applied, and that the error \lstinline$DDMPO:BadCOMPRESS$ is thrown if a bad value of \lstinline$COMPRESS$ is supplied. It checks that the trace is one, and that a sample of the density matrix elements are all equal to one another.

 \subsubsection{ZDMPO}
 \paragraph{Docstring} This is a constructor function for a density matrix product operator. This function creates a DMPO which represents a density matrix with the same real value as every element, precisely the same as \lstinline$DDMPO$. The difference is in the construction -- \lstinline$ZDMPO$ fills every element in every tensor \(A^{[n]}\) with a complex number. This is useful for testing and debugging, as the very sparse and completely real tensors created by \lstinline$DDMPO$ can sometimes help conceal bugs. This function depends on \lstinline$TrNorm$.
 \begin{lstlisting}
 function [dmpo] = ZDMPO(HILBY, LENGTH, COMPRESS) \end{lstlisting}
 \begin{longtabu}{X[1,l]X[4,l]}
 \hline
 Return & \\ \hline
 \lstinline$dmpo$ & \emph{\(N \times 1\) cell array}. A density matrix product operator in the standard format. Created by filling every site tensor with the complex number \(Z = \frac{1}{\sqrt{2}}(1 + 1i)\). The density matrix product operator is then trace normalised. \\ \hline
 Input & \\ \hline
 \lstinline$HILBY$ & \emph{Double}. The size of the local state space, \(d\). Should be a positive integer, greater than one.  \\
 \lstinline$LENGTH$ & \emph{Double}. The number of sites in the system, \(N\). Should be a positive integer greater than one. \\
 \lstinline$COMPRESS$ & \emph{Double}. The maximum size, \(\chi_{\mathrm{max}}\) of the virtual dimensions of the density matrix product state site tensors, \(A^{[n]}\). As in the ground state code, if \lstinline$COMPRESS == 0$, it will be set to \lstinline$Inf$, leaving the density matrix product operator uncompressed. Should be a positive integer either equal to zero, or greater than or equal to \(d^{2}\). If \(0 <\) \lstinline$COMPRESS$ \(< d^{2}\) an error will be thrown. \\
 \hline
 \end{longtabu}
 \paragraph{Testing} \lstinline$ZDMPOTest$. Checks that the density matrix product operator is the right type, size, and shape, including that compression is properly applied. Additionally, the test checks that the error \lstinline$ZDMPO:BadCOMPRESS$ is thrown in the event of a bad value of \lstinline$COMPRESS$ being supplied, and that the state is trace normalised.
 
  \subsubsection{ProdDMPO}
 \paragraph{Docstring} This is a constructor function for a density matrix product operator. It creates a density matrix product operator which represents a specified simple product state. That is it forms the density matrix,
 \begin{equation}
 \rho = | i_{1} i_{2} \ldots i_{N} \rangle \langle i_{1} i_{2} \ldots i_{N} |,
 \label{eq:vs3-3}
 \end{equation}
 for some product state \(|i_{1} i_{2} \ldots i_{N} \rangle\). This function depends on \lstinline$FWBase$.
 \begin{lstlisting}
 function [prodDMPO] = ProdDMPO(HILBY, LENGTH, COMPRESS, STATE) \end{lstlisting}
 \begin{longtabu}{X[1,l]X[4,l]}
 \hline
 Return & \\ \hline
 \lstinline$prodDMPO$ & \emph{\(N \times 1\) cell array}. A density matrix product operator in the standard format which corresponds to a simple product state, specified by \lstinline$STATE$. Created by initialising all tensors \(A^{[n]}\) as zero arrays, and then replacing the appropriate \(A^{[n]}_{i,j}\) matrices with identities. \\ \hline
 Input & \\ \hline
 \lstinline$HILBY$ & \emph{Double}. The size of the local state space, \(d\). Should be a positive integer, greater than 1. \\
 \lstinline$LENGTH$ & \emph{Double}. The number of sites in the system, \(N\). Should be a positive integer, greater than 1. \\
 \lstinline$COMPRESS$ & \emph{Double}. The maximum size, \(\chi_{\mathrm{max}}\) of the virtual dimensions of the density matrix product state site tensors, \(A^{[n]}\). If \lstinline$COMPRESS == 0$, it will be set to \lstinline$Inf$, leaving the density matrix product operator uncompressed. Should be a positive integer either equal to zero, or greater than or equal to \(d^{2}\). If \(0 <\) \lstinline$COMPRESS$ \(< d^{2}\) an error will be thrown. \\
 \lstinline$STATE$ & \emph{Double}. The decimal value given by treating the desired state as a big-endian, \(N\)-bit, base \(d\) string. For example for any size system, \lstinline$STATE = 0$ gives the state \(| 0_{1} 0_{2} \ldots 0_{N} \rangle \). For a 3 site, 3-level system, \lstinline$STATE = 12$ would correspond to the state \(|1_{1} 1_{2} 0_{3} \rangle\).  \\
 \hline
 \end{longtabu}
 \paragraph{Testing} \lstinline$ProdDMPOTest$. Checks the type, size, and shape of the density matrix product operator. It checks that compression is properly applied, and that the error \lstinline$ProdDMPO:BadCOMPRESS$ is thrown if a bad value of \lstinline$COMPRESS$ is supplied. It checks that the trace is one, and that the specific density matrix element corresponding to the specified state is one.
 
 \subsubsection{Can}
 
 \subsubsection{GrowBlock}
 
 \subsubsection{EffL}
 
 \subsubsection{EigenSolver}
 
 \subsubsection{DMPOResize}
 
 \subsubsection{TrNorm}
 \paragraph{Docstring} Normalises a density matrix product operator by dividing it by its trace. This function depends on \lstinline$DMPOTrace$, and \lstinline$DMPOScalarDiv$.
 \begin{lstlisting}
 function [normDMPO] = TrNorm(dmpo) \end{lstlisting}
 \begin{longtabu}{X[1,l]X[4,l]}
 \hline
 Return & \\ \hline
 \lstinline$normDMPO$ & \emph{\(N \times 1\) cell array}. A trace normalised density matrix product operator, in the standard format. \\ \hline
 Input & \\ \hline
 \lstinline$dmpo$ & \emph{\(N \times 1\) cell array}. A density matrix product operator which is to be trace normalised, in the standard format. \\
 \hline
 \end{longtabu}
 \paragraph{Testing} \lstinline$TrNormTest$. Checks that \lstinline$normDMPO$ has the same class, size, and shape as \lstinline$dmpo$, and checks that the trace is one.
  
 \subsubsection{DMPOHerm}
 \paragraph{Docstring} This function returns the Hermitian part of a supplied density matrix product operator. It does this by performing the following operation, 
 \begin{equation}
 \tilde{\rho} = \frac{\rho + \rho^{\dagger}}{2}.
 \label{eq:vs3-2}
 \end{equation}
 It should be noted that the operation to add two matrix product operators involves doubling the size of the virtual dimensions on each site. Consequently, this function will do the same regardless of what compression limits may have been previously set. The state should therefore be compressed after the use of this function. This function depends on \lstinline$DMPOConj$, \lstinline$DMPOSum$, and \lstinline$DMPOScalarDiv$.
 \begin{lstlisting}
 function [hermDMPO] = DMPOHerm(dmpo) \end{lstlisting}
 \begin{longtabu}{X[1,l]X[4,l]}
 \hline
 Return & \\ \hline
 \lstinline$hermDMPO$ & \emph{\(N \times 1\) cell array}. The hermitian part of the supplied density matrix product operator, in the standard format. Will have double the virtual dimensions on each site, so should be compressed. \\ \hline
 Input & \\ \hline
 \lstinline$dmpo$ & \emph{\(N \times 1\) cell array}. Some density matrix product operator, in the standard format. \\
 \hline
 \end{longtabu}
 \paragraph{Testing} \lstinline$DMPOHermTest$. Checks the \lstinline$hermDMPO$ has the right type, size, and shape. Additionally checks that the trace has been preserved from the input, that the trace is real, and that \lstinline$hermDMPO$ is Hermitian. It does the test for Hermiticity by sampling elements from the density matrix, and checking the transpose element.
 
\subsubsection{LCan}
 \paragraph{Docstring} This function is the density matrix product operator version of the function with the same name in the ground state search code. It does exactly the same job of left-normalising the site tensors, while taking account of the additional indices in the stationary state search.
 \begin{lstlisting}
 function [ldmpo] = LCan(dmpo, route) \end{lstlisting}
  \begin{longtabu}{X[1,l]X[4,l]}
 \hline
 Return & \\ \hline
 \lstinline$ldmpo$ & \emph{\(N \times 1\) cell array}. A density matrix product operator in the standard format, with site tensors along the specified route made left-canonical. \\ \hline
 Input & \\
 \lstinline$dmpo$ & \emph{\(N \times 1\) cell array}. A density matrix product operator, in the standard format. \\
 \lstinline$route$ & \emph{1 dimensional double array}. Specifies the site, or sites which are to be made left-canonical. Should be all integers, and form a continuous path through system i.e. \lstinline$[start : 1 : stop]$. The last site in \lstinline$route$ cannot be the last site in the system. If it is, an error will be thrown. \\
 \hline
 \end{longtabu} 
 \paragraph{Testing} \lstinline$LCanTest$. Checks the type, size, and shape of the returned density matrix product operator. Checks that a bad route throws the correct error. Checks that the function does not alter the trace, or a sample of the elements of the density matrix. 
 
 \subsubsection{RCan}
 \paragraph{Docstring} This function is the density matrix product operator version of the function with the same name in the ground state search code. It does exactly the same job of right-normalising the site tensors, while taking account of the additional indices in the stationary state search.
 \begin{lstlisting}
 function [rdmpo] = RCan(dmpo, route) \end{lstlisting}
  \begin{longtabu}{X[1,l]X[4,l]}
 \hline
 Return & \\ \hline
 \lstinline$rdmpo$ & \emph{\(N \times 1\) cell array}. A density matrix product operator in the standard format, with site tensors along the specified route made right-canonical. \\ \hline
 Input & \\
 \lstinline$dmpo$ & \emph{\(N \times 1\) cell array}. A density matrix product operator, in the standard format. \\
 \lstinline$route$ & \emph{1 dimensional double array}. Specifies the site, or sites which are to be made right-canonical. Should be all integers, and form a continuous path through system i.e. \lstinline$[start : -1 : stop]$. The last site in \lstinline$route$ cannot be the first site in the system. If it is, an error will be thrown. \\
 \hline
 \end{longtabu}
 \paragraph{Testing} \lstinline$RCanTest$.  Checks the type, size, and shape of the returned density matrix product operator. Checks that a bad route throws the correct error. Checks that the function does not alter the trace, or a sample of the elements of the density matrix. 
 
 \subsubsection{GrowLeft}
 \paragraph{Docstring} This function is the density matrix product operator version of the function with the same name in the ground state search code. It does exactly the same job of enlarging the left tensor block, while taking account of the additional indices in the stationary state search.
 \begin{lstlisting}
 function [updateBlock] = GrowLeft(siteTensor, mpo, leftBlock, ROW_SIZE, COL_SIZE, HILBY, OP_ROW, OP_COL) \end{lstlisting}
 \begin{longtabu}{X[1,l]X[4,l]}
 \hline
 Return & \\ \hline
 \lstinline$updateBlock$ & \emph{3 dimensional complex double array}. The rank-3 left block tensor for the site \(n + 1\), \(L^{[n+1]}\). \\ \hline
 Input & \\ \hline
 \lstinline$siteTensor$ & \emph{4 dimensional complex double array}. The density matrix product operator tensor for the site \(n\), in the standard format. \\
 \lstinline$leftBlock$ & \emph{3 dimensional complex double array}. The rank-3 left block tensor for the site \(n\), \(L^{[n]}\). \\
 \lstinline$mpo$ & \emph{6 dimensional complex double array}. The rank-6 tensor matrix product operator for the site \(n\), \(O^{[n]}\). The indexing format is \lstinline$mpo(bra, ket, conjBra, conjKet, opRow, opCol)$, where \lstinline$bra$ and \lstinline$ket$ are the physical indices for the density matrix product operator, \lstinline$conjBra$ and \lstinline$conjKet$ are the physical indices for the conjugate density matrix product operator, and \lstinline$opRow$ and \lstinline$opCol$ are the virtual indices for the matrix product operator. \\
 \lstinline$ROW_SIZE$ & \emph{Double}. The size of the the first virtual dimension of the density matrix product operator. Should be a positive integer. \\
 \lstinline$COL_SIZE$ & \emph{Double}. The size of the second virtual dimension of the density matrix product operator. Should be a positive integer. \\ 
 \lstinline$HILBY$ & \emph{Double}. The size of the local state space, \(d\). Should be a positive integer, greater than 1. \\
 \lstinline$OP_ROW$ & \emph{Double}. The size of the first virtual dimension of the matrix product operator. Should be a positive integer. \\
 \lstinline$OP_COL$ & \emph{Double}. The size of the second virtual dimension of the matrix product operator. Should be a positive integer. \\
 \hline
 \end{longtabu}
 \paragraph{Testing} \lstinline$GrowLeftTest$. Checks the vector norm of the system, by calling \lstinline$GrowLeft$ on the last site.
 
 \subsubsection{GrowRight}
 \paragraph{Docstring} This function is the density matrix product operator version of the function with the same name in the ground state search code. It does exactly the same job of enlarging the right tensor block, while taking account of the additional indices in the stationary state search.
 \begin{lstlisting}
 function [updateBlock] = GrowRight(siteTensor, mpo, rightBlock, ROW_SIZE, COL_SIZE, HILBY, OP_ROW, OP_COL) \end{lstlisting}
 \begin{longtabu}{X[1,l]X[4,l]}
 \hline
 Return & \\ \hline
 \lstinline$updateBlock$ & \emph{3 dimensional complex double array}. The rank-3 right block tensor for the site \(n - 1\), \(R^{[n-1]}\). \\ \hline
 Input & \\ \hline
 \lstinline$siteTensor$ & \emph{4 dimensional complex double array}. The density matrix product operator tensor for the site \(n\), in the standard format. \\
 \lstinline$rightBlock$ & \emph{3 dimensional complex double array}. The rank-3 right block tensor for the site \(n\), \(R^{[n]}\). \\
 \lstinline$mpo$ & \emph{6 dimensional complex double array}. The rank-6 tensor matrix product operator for the site \(n\), \(O^{[n]}\). The indexing format is \lstinline$mpo(bra, ket, conjBra, conjKet, opRow, opCol)$, where \lstinline$bra$ and \lstinline$ket$ are the physical indices for the density matrix product operator, \lstinline$conjBra$ and \lstinline$conjKet$ are the physical indices for the conjugate density matrix product operator, and \lstinline$opRow$ and \lstinline$opCol$ are the virtual indices for the matrix product operator. \\
 \lstinline$ROW_SIZE$ & \emph{Double}. The size of the the first virtual dimension of the density matrix product operator. Should be a positive integer. \\
 \lstinline$COL_SIZE$ & \emph{Double}. The size of the second virtual dimension of the density matrix product operator. Should be a positive integer. \\ 
 \lstinline$HILBY$ & \emph{Double}. The size of the local state space, \(d\). Should be a positive integer, greater than 1. \\
 \lstinline$OP_ROW$ & \emph{Double}. The size of the first virtual dimension of the matrix product operator. Should be a positive integer. \\
 \lstinline$OP_COL$ & \emph{Double}. The size of the second virtual dimension of the matrix product operator. Should be a positive integer. \\
 \hline
 \end{longtabu}
 \paragraph{Testing} \lstinline$GrowRightTest$. Checks the vector norm of the system, by calling \lstinline$GrowRight$ on the first site.
 
 \subsubsection{EffLSparse} 
 
 \subsubsection{DMPOCompress}
 \paragraph{Docstring} This function compresses the virtual dimensions of a density matrix product operator, so that they do not exceed the limit \(\chi_{\mathrm{max}}\), set by \lstinline$COMPRESS$. A QR decomposition is performed at each site, and only the first \lstinline$COMPRESS$ rows and columns of the matrix \(Q\) are kept. 
 \begin{lstlisting}
 function [compDMPO] = DMPOCompress(dmpo, COMPRESS) \end{lstlisting}
 \begin{longtabu}{X[1,l]X[4,l]}
 \hline
 Return & \\ \hline
 \lstinline$compDMPO$ & \emph{\(N \times 1\) cell array}. A density matrix product operator whose virtual dimensions do not exceed the limit set by \lstinline$COMPRESS$, in the standard format. \\ \hline
 Input & \\ \hline
 \lstinline$dmpo$ & \emph{\(N \times 1\) cell array}. A density matrix product operator, in the standard format. \\
 \lstinline$COMPRESS$ & \emph{Double}. The maximum size, \(\chi_{\mathrm{max}}\) of the virtual dimensions of the density matrix product state site tensors, \(A^{[n]}\). Should be a positive integer greater than or equal to \(d^{2}\). If it is less than \(d^{2}\), an error will be thrown. \\
 \hline
 \end{longtabu}
 \paragraph{Testing} \lstinline$DMPOCompressTest$. Checks that the type and size of \lstinline$compDMPO$ are correct, and checks that it is still possible to multiply through the chain of site tensors, and that the virtual dimensions do not exceed \lstinline$COMPRESS$. Checks that the trace is unity, and real. Additionally, it is checked that the trace is not changed by compression, however, for strong compression it will be.
 \paragraph{Improvements}
 \begin{itemize}
 \item Testing that the trace doesn't drift after compression isn't very helpful, as in general, it will.
 \item Should test specifically that no virtual dimension exceeds \lstinline$COMPRESS$ since that is the point of the function.
 \end{itemize}

 \subsubsection{DMPOEnlarge}
  
 \subsubsection{DMPOTrace}
 \paragraph{Docstring} This function calculates the trace of a density matrix product operator. It uses the same contraction as \lstinline$DMPOExp$, only it ignores non-diagonal terms. 
 \begin{lstlisting}
 function [trace] = DMPOTrace(dmpo) \end{lstlisting}
 \begin{longtabu}{X[1,l]X[4,l]}
 \hline
 Return & \\ \hline
 \lstinline$trace$ & \emph{Complex double}. The trace of the supplied density matrix product operator. Should always be exactly equal to one, with no imaginary component, but this will often not be the case. \\ \hline
 Input & \\ \hline
 \lstinline$dmpo$ & \emph{\(N \times 1\) cell array}. A density matrix product operator, in the standard format. \\
 \hline
 \end{longtabu}
 \paragraph{Testing} Creates a `density matrix' of all ones for various sizes of system, and then confirms that the trace is real, and equal to \(d^{N}\). 
  
 \subsubsection{DMPOScalarDiv}
 \paragraph{Docstring} This function divides a density matrix product operator by a scalar value. Currently it does so simply by dividing the first site tensor \(A^{[1]}\) by the scalar.
 \begin{lstlisting}
 function [divDMPO] = DMPOScalarDiv(dmpo, scalar) \end{lstlisting}
 \begin{longtabu}{X[1,l]X[4,l]}
 \hline
 Return & \\ \hline
 \lstinline$divDMPO$ & \emph{\(N \times 1\) cell array}. A density matrix product operator in the standard format which represents the density matrix, \(\tilde{\rho} = \rho / a\), where \(\rho\) is the density matrix represented by \lstinline$dmpo$, and \(a\) is the scalar value supplied as \lstinline$scalar$. \\ \hline
 Input & \\ \hline
 \lstinline$dmpo$ & \emph{\(N \times 1\) cell array}. Some density matrix product operator, in the standard format. \\
 \lstinline$scalar$ & \emph{Complex double}. Some complex (or real) number. \\
 \hline
 \end{longtabu}
 \paragraph{Testing} \lstinline$DMPOScalarDivTest$. Checks that type, size, and shape of the returned density matrix product operator. Checks that \(\mathrm{Tr}[\tilde{\rho}] = \mathrm{Tr}[\rho] / a\), and by sampling elements from the density matrix, that the division has been carried out correctly.
 
 \subsubsection{ConvTest}  
  
 \subsubsection{DMPOConj}
 \paragraph{Docstring} This function calculates the Hermitian conjugate density matrix product operator, by conjugating the matrices \(A^{[n]}_{i,j}\), and swapping their physical indices.
 \begin{lstlisting}
 function [conjDMPO] = DMPOConj(dmpo) \end{lstlisting}
 \begin{longtabu}{X[1,l]X[4,l]}
 \hline
 Return & \\ \hline
 \lstinline$conjDMPO$ & \emph{\(N \times 1\) cell array}. A density matrix product operator, in the standard format. Represents the density matrix \(\rho^{\dagger}\), where \(\rho\) is the density matrix represented by the density matrix product operator, \lstinline$dmpo$. \\ \hline
 Input & \\ \hline
 \lstinline$dmpo$ & \emph{\(N \times 1\) cell array}. A density matrix product operator, in the standard format. Represents the density matrix, \(\rho\). \\
 \hline
 \end{longtabu}
 \paragraph{Testing} \lstinline$DMPOConjTest$. Checks the type, size, and shape of the returned density matrix product operator. Checks that its trace is unity, and by sampling elements, that it is the Hermitian conjugate of the input density matrix product operator.
 
 \subsubsection{DMPOExp}
 \paragraph{Docstring} This function calculates the expectation value of some set of locally acting operator \(\hat{O}\), by calculating \(\mathrm{Tr}[\hat{O}\rho]\). The format of the operator here is that it should be a three dimensional complex double array, with the first two indices referencing the local physical state, and the third indexing the site. 
 \begin{lstlisting}
 function [expect] = DMPOExp(dmpo, op) \end{lstlisting}
 \begin{longtabu}{X[1,l]X[4,l]}
 \hline
 Return & \\ \hline
 \lstinline$expect$ & \emph{Complex double}. The expectation value corresponding to \(\mathrm{Tr}[\hat{O}\rho]\).  \\ \hline
 Input & \\ \hline
 \lstinline$dmpo$ & \emph{\(N \times 1\) cell array}. Some density matrix product operator, in the standard format. \\
 \lstinline$op$ & \emph{3 dimensional complex double array}. Some set of locally acting operators, in the format \(\langle\)\lstinline$braState$\(| \hat{O}^{[n]} |\)\lstinline$ketState$\(\rangle =\) \lstinline$op(braState, ketState, site)$. For example, if one wanted to calculate the expectation of the spin-flip operator acting on the first site in a spin chain, then \lstinline$op(:, :, 1)$, would be the spin-flip operator 
\(\left(
 \begin{smallmatrix} 
 0 & 1 \\ 1 & 0
 \end{smallmatrix}
\right),\) while every other matrix in the array, \lstinline$op(:, :, 2:end)$, would be the \(2 \times 2\) identity matrix.\\
 \hline
 \end{longtabu}
 \paragraph{Testing} \lstinline$DMPOExpTest$. Checks the type of \lstinline$expect$, the trace of a set of density matrix product operators, and the expectation value of \(\hat{n}\) on some product states.
 
 \subsubsection{DMPOSum}
 \paragraph{Docstring} This function adds two density matrix product operators, which represent the same system, together. Given two density matrix product operators, 
 \begin{align}
 |\bar{\rho}_{A} \rangle &= \sum_{i_{1}\ldots i_{N}} \sum_{j_{1} \ldots j_{N}} A^{[1]}_{i,j} A^{[2]}_{i,j} \ldots A^{[N]}_{i,j} |j_{1} j_{2} \ldots j_{N} \rangle \otimes |i_{1} i_{2} \ldots i_{N} \rangle, \label{eq:vs3-5} \\
 |\bar{\rho}_{B} \rangle &= \sum_{l_{1} \ldots l_{N}} \sum_{m_{1} \ldots m_{N}} B^{[1]}_{l,m} B^{[2]}_{l,m} \ldots B^{[N]}_{l,m} |m_{1} m_{2} \ldots m_{N} \rangle \otimes |l_{1} l_{2} \ldots l_{N} \rangle, \label{eq:vs3-6} 
 \end{align}
 we perform the summation, \(|\bar{\rho}_{C} \rangle = |\bar{\rho}_{A} \rangle + |\bar{\rho}_{B} \rangle\) with the following procedure. We form \(C^{[1]}\) by concatenating \(A^{[1]}\) and \(B^{[1]}\) along the second virtual dimension, and we form \(C^{[N]}\) by concatenating \(A^{[N]}\) and \(B^{[N]}\) along the first virtual dimension. For all the other sites, we create the block diagonal matrices,
 \begin{equation}
 C^{[n]} = \begin{pmatrix}
 A^{[n]} & 0 \\ 
 0 & B^{[n]} \end{pmatrix}, 
 \label{eq:vs3-7}
 \end{equation}
 which we can see leads to \(|\bar{\rho}_{C} \rangle \) having virtual dimensions which are the sum of those in \(|\bar{\rho}_{A}\rangle\) and \(\bar{\rho}_{B}\rangle\). It is also not trace normalised. For this reason it is recommended that any use of \lstinline$DMPOSum$ is followed by \lstinline$DMPOCompress$ and \lstinline$TrNorm$. 
 \begin{lstlisting}
 function [sumDMPO] = DMPOSum(rhoA, rhoB) \end{lstlisting}
 \begin{longtabu}{X[1,l]X[4,l]}
 \hline
 Return & \\ \hline
 \lstinline$sumDMPO$ & \emph{\(N \times 1\) cell array}. An un-normalised density matrix product operator, in the standard format. Represents a density matrix which is the sum of those represented by the input density matrix product operators. \\ \hline
 Input & \\ \hline
 \lstinline$rhoA$ & A density matrix product operator, in the standard format. If its size and physical dimensions do not match those of \lstinline$rhoB$, an error will be thrown. \\ 
 \lstinline$rhoB$ & A density matrix product operator, in the standard format. If its size and physical dimensions do not match those of \lstinline$rhoA$, an error will be thrown. \\ 
 \hline
 \end{longtabu}
 \paragraph{Testing} \lstinline$DMPOSumTest$. Checks the type, size, and shape of \lstinline$sumDMPO$. Checks that an error is thrown if the two input systems do not match. Checks that the trace of \lstinline$sumDMPO$ is the sum of the trace of \lstinline$rhoA$ and \lstinline$rhoB$, and samples the density matrix to check the summation has been performed correctly.  
 
 \subsubsection{FWBase}
 \paragraph{Docstring} This is a utility function which returns an array containing the big-endian, \(N\)-bit, base \(d\) representation of a decimal number. It is used by \lstinline$ProdDMPO$, and extensively by test routines. 
 \begin{lstlisting}
 function [bits] = FWBase(n, BASE, WIDTH) \end{lstlisting}
 \begin{longtabu}{X[1,l]X[4,l]}
 \hline
 Return & \\ \hline
 \lstinline$bits$ & \emph{\lstinline$WIDTH$ \(\times 1\) double array}. Contains the big-endian, base \lstinline$BASE$ representation of \lstinline$n$. Will be padded with zeroes to ensure it reaches \lstinline$WIDTH$. \\ \hline
 Input & \\ \hline
 \lstinline$n$ & \emph{Double}. A decimal number. Should be a positive integer, if it is not, an error will be thrown. \\
 \lstinline$BASE$ & \emph{Double}. The base into which \lstinline$n$ should be converted. Should be a positive integer. \\
 \lstinline$WIDTH$ & \emph{Double}. The size of the bit string required. If it is longer than necessary for the chosen \lstinline$n$ and \lstinline$BASE$, it will be padded with leading zeroes. If it is not large enough, an error will be thrown. \\
 \hline
 \end{longtabu}
 \paragraph{Testing} \lstinline$FWBaseTest$. Checks that errors are thrown correctly, and that the right size arrays are created. Checks that decimal numbers are converted correctly.
 
 \subsubsection{MPOHermProd} 
 
 \subsubsection{SVDNorm}
 \paragraph{Docstring} This function uses the SVD (or in fact the QR) decomposition to vector normalise a density matrix product operator. Essentially the same as \lstinline$LCan$, except it includes the last site in the system, and simply throws away the last \(V^{\dagger}\) or \(R\) matrix. Has no impact on the physicality of the density matrix product operator, so should only be used at initialisation. Thereafter the process of left and right normalising individual site tensors ensures that the density matrix product operator remains vector normalised. 
 \begin{lstlisting}
 function [normDMPO] = SVDNorm(dmpo) \end{lstlisting}
 \begin{longtabu}{X[1,l]X[4,l]}
 \hline
 Return & \\ \hline
 \lstinline$normDMPO$ & \emph{\(N \times 1\) cell array}. A vector normalised density matrix product operator in the standard format. \\ \hline
 Input & \\ \hline
 \lstinline$dmpo$ & \emph{\(N \times 1\) cell array}. A density matrix product operator, in the standard format. \\ 
 \hline
 \end{longtabu}
 \paragraph{Testing} \lstinline$SVDNormTest$. Checks the type, size, and shape of the returned density matrix product operator. Using a small system rebuilds the full vectorised density matrix, and confirms it has a vector norm of one.  